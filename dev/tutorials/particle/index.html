<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Particle handling · ParticleHolography.jl</title><meta name="title" content="Particle handling · ParticleHolography.jl"/><meta property="og:title" content="Particle handling · ParticleHolography.jl"/><meta property="twitter:title" content="Particle handling · ParticleHolography.jl"/><meta name="description" content="Documentation for ParticleHolography.jl."/><meta property="og:description" content="Documentation for ParticleHolography.jl."/><meta property="twitter:description" content="Documentation for ParticleHolography.jl."/><meta property="og:url" content="https://dainakai.github.io/ParticleHolography.jl/tutorials/particle/"/><meta property="twitter:url" content="https://dainakai.github.io/ParticleHolography.jl/tutorials/particle/"/><link rel="canonical" href="https://dainakai.github.io/ParticleHolography.jl/tutorials/particle/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/styles.css" rel="stylesheet" type="text/css"/><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="ParticleHolography.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ParticleHolography.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../whats_inline_holography/">What&#39;s inline holography?</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../gabor/">Gabor holography</a></li><li><a class="tocitem" href="../pr/">Phase retrieval holography</a></li><li class="is-active"><a class="tocitem" href>Particle handling</a><ul class="internal"><li><a class="tocitem" href="#Particle-detection"><span>Particle detection</span></a></li><li><a class="tocitem" href="#Scatter-plotting"><span>Scatter plotting</span></a></li><li><a class="tocitem" href="#Particle-pairing"><span>Particle pairing</span></a></li><li><a class="tocitem" href="#Trajectory-plotting"><span>Trajectory plotting</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li></ul></li><li><span class="tocitem">Usage</span><ul><li><a class="tocitem" href="../../usage/preprocessings/">Preprocessings</a></li><li><a class="tocitem" href="../../usage/reconstruction/">Volume reconstruction</a></li><li><a class="tocitem" href="../../usage/lowpassfilter/">Low-pass filtering</a></li><li><a class="tocitem" href="../../usage/animplot/">Animated plots</a></li></ul></li><li><a class="tocitem" href="../../reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Particle handling</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Particle handling</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/dainakai/ParticleHolography.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/dainakai/ParticleHolography.jl/blob/main/docs/src/tutorials/particle.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="particle_handling"><a class="docs-heading-anchor" href="#particle_handling">Particle handling</a><a id="particle_handling-1"></a><a class="docs-heading-anchor-permalink" href="#particle_handling" title="Permalink"></a></h1><p>This section explains the method of detecting particles from the hologram reconstruction volume, performing particle pairing on time-series data, and tracking particle trajectories.</p><h2 id="Particle-detection"><a class="docs-heading-anchor" href="#Particle-detection">Particle detection</a><a id="Particle-detection-1"></a><a class="docs-heading-anchor-permalink" href="#Particle-detection" title="Permalink"></a></h2><p>We start by detecting particles from the reconstructed image stack of the hologram. The process begins with binarizing the reconstruction stack using a global threshold and then performing connected component labeling to create bounding boxes for the particles. Various methods and values should be considered when determining the global threshold. It&#39;s advisable to use tools like ImageJ to adjust and decide on the threshold. The <code>cu_get_reconst_vol</code> function returns a reconstruction stack of type <code>N0f8</code> by default, which can be saved as an nrrd file using <code>NRRD.jl</code> and opened in Fiji as an 8-bit grayscale image stack (Tiff stack files are easier to open in ImageJ, but that process seems to be more complex). Among the binarization methods provided by these tools, the Minimum method often yields the best threshold. For time-series data, it&#39;s good to use a consistent threshold throughout the measurement series if lighting conditions remain unchanged.</p><p>Although not shown in the following example, when working with experimental data or reconstructed images where artifacts may occur and you want to set a strict threshold, it&#39;s beneficial to use the <code>cu_dilate</code> function to expand the binarized volume <code>d_bin_vol</code>. Ideally, the particle mask <code>d_bin_vol</code> should cover an area slightly larger than the true particle image. This is because depth position determination methods may examine the difference between the particle image and its surroundings or utilize the gradient intensity of the particle contour. This expansion process is a normal dilation operation and is executed on the GPU, similar to the reconstruction process.</p><p>The connected component labeling applied to the binarized volume is not a strict 3D labeling in the conventional sense. First, 2D connected component labeling [<a href="#playne">12</a>] (<a href="https://github.com/FolkeV/CUDA_CCL">GPU implementation</a>) is performed on each slice, and then elements that overlap even partially in x-y coordinates across all slices are considered identical. In other words, this process does not distinguish between different particles that overlap in x-y coordinates. As long as particles do not overlap, this method provides rough Bounding Boxes for particles and suppresses ghost particles. After completing the labeling and Bounding Box creation for all slices, we exclude those that can be considered ghost particles or are too small to observe. For more details, refer to the <a href="../../reference/#ParticleHolography.finalize_particle_neighborhoods!-Tuple{Any}"><code>finalize_particle_neighborhoods!</code></a> function.</p><p>The particle Bounding Boxes are provided in dictionary format. The <code>key</code> is a UUID, and the <code>value</code> is in the format <code>[xmin, ymin, zmin, xmax, ymax, zmax]</code>. This is used to evaluate the coordinates and size of the particles. The UUID keys assigned during the creation of Bounding Boxes are carried over to create a new dictionary, which is then returned. If only coordinates are evaluated, the key is a 3-dimensional vector; if particle size is also evaluated, it&#39;s 4-dimensional. Evaluation functions can take depth position determination methods and particle size evaluation methods as arguments. For more details, refer to the respective functions: <a href="../../reference/#ParticleHolography.particle_coordinates-Tuple{Dict{Base.UUID, Vector{Int64}}, CUDA.CuArray{FixedPointNumbers.N0f8, 3}}"><code>particle_coordinates</code></a>, <a href="../../reference/#ParticleHolography.particle_coor_diams"><code>particle_coor_diams</code></a></p><pre><code class="language-julia hljs">using ParticleHolography
using CUDA

λ = 0.6328 # Wavelength [μm]
Δx = 10.0 # Pixel size [μm]
z0 = 80000.0 # Optical distance between the hologram and the front surface of the reconstruction volume [μm]
Δz = 100.0 # Optical distance between the reconstructed slices [μm]
datlen = 1024 # Data length
slices = 1000 # Number of slices
pr_dist = 80000.0 # Optical distance between the two holograms [μm]
pr_iter = 9
threshold = 30/255

img1 = load_gray2float(&quot;./holo1.png&quot;)
img2 = load_gray2float(&quot;./holo2.png&quot;)

d_sqr = cu_transfer_sqrt_arr(datlen, λ, Δx)
d_tf = cu_transfer(-z0, datlen, λ, d_sqr)
d_slice = cu_transfer(-Δz, datlen, λ, d_sqr)
d_pr = cu_transfer(pr_dist, datlen, λ, d_sqr)
d_pr_inv = cu_transfer(-pr_dist, datlen, λ, d_sqr)

# Phase retrieval using Gerchberg-Saxton algorithm
d_holo = cu_phase_retrieval_holo(cu(img1), cu(img2), d_pr, d_pr_inv, pr_iter, datlen)

# Reconstruction
d_vol = cu_get_reconst_vol(d_holo, d_tf, d_slice, slices)

# Binarization
d_bin_vol = d_vol .&lt;= threshold

particle_bbs = particle_bounding_boxes(d_bin_vol)
particle_coords = particle_coordinates(particle_bbs, d_vol)

# Save the particle coordinates
dictsave(&quot;particles.json&quot;, particle_coords)</code></pre><h2 id="Scatter-plotting"><a class="docs-heading-anchor" href="#Scatter-plotting">Scatter plotting</a><a id="Scatter-plotting-1"></a><a class="docs-heading-anchor-permalink" href="#Scatter-plotting" title="Permalink"></a></h2><p>Let&#39;s plot the detected particles at each time point as a scatter plot. Since the correspondence of particles between time-series frames is still unknown at this point, we&#39;ll plot the particles at each time point in different colors. The plot recipe <a href="../../reference/#ParticleHolography.particleplot-Tuple"><code>particleplot</code></a> provided by ParticleHolography.jl is a simple arrangement of <code>Plots.scatter()</code>, but please note that there are differences in how the coordinate axes are handled.</p><pre><code class="language-julia hljs">using ParticleHolography
using Plots
using Glob

files = glob(&quot;savejson_lpf4_priter6_th24/*.json&quot;)[1:50]

colors = cgrad(:viridis)[LinRange(0, 1, length(files))]
plot()
for (idx, file) in enumerate(files)
    data = dictload(file)
    particleplot!(data, legend = false, scaling=(10.0, 10.0, -100.0), shift=(0.0, 0.0, 1e5), color=colors[idx], xlabel=&quot;x [µm]&quot;, ylabel=&quot;z [µm]&quot;, zlabel=&quot;y [µm]&quot;, xlim=(0,10240), ylim=(0,1e5), zlim=(0,10240))
end

plot!()</code></pre><p><img src="../../assets/particleplot.png" alt="Detected particles"/></p><h2 id="Particle-pairing"><a class="docs-heading-anchor" href="#Particle-pairing">Particle pairing</a><a id="Particle-pairing-1"></a><a class="docs-heading-anchor-permalink" href="#Particle-pairing" title="Permalink"></a></h2><p>While overlaying detected particles from each time series creates an impactful and attractive image, what&#39;s truly crucial for many is understanding the correspondence of particle positions between time series frames. In other words, which particle in one frame corresponds to which in the next? When particle density is relatively low, a nearest neighbor approach suffices. However, as density increases, more advanced techniques become necessary. That said, particle tracking velocimetry (PTV) methods for extremely high particle densities, such as those described by [<a href="#schanz">13</a>], are unnecessary in our context. This is because hologram reconstruction becomes challenging when particle image areas exceed 20% of the x-y projection of the reconstructed image (refer to <a href="../gabor/#gabor_reconst">Gabor holography</a>). ParticleHolography.jl employs an improved version of Labonté&#39;s algorithm [<a href="#ohmi">14</a>, <a href="#labonte">15</a>] for particle pairing.</p><p>Labonté&#39;s algorithm elucidates the correspondence between particles in two consecutive time frames. In ParticleHolography.jl, this relationship is represented as a directed graph through the <a href="../../reference/#ParticleHolography.Labonte-Tuple{Any, Any}"><code>Labonte</code></a> implementation. To track particles across three or more consecutive frames and obtain all trajectories, we combine these directed graphs and enumerate all paths from each starting point to each endpoint. The functions <a href="../../reference/#ParticleHolography.enum_edge"><code>enum_edge</code></a> and <a href="../../reference/#ParticleHolography.append_path!-Tuple{Any, MetaGraphsNext.MetaGraph}"><code>append_path!</code></a> perform these operations.</p><pre><code class="language-julia hljs">using ParticleHolography
using Glob

# Load the particle coordinates
files = glob(&quot;savejson_lpf4_priter6_th24/*.json&quot;)[1:5]

# Convert to dictionary with UUID keys and Float64 values
dicts = ParticleHolography.dictload.(files)

graphs = [Labonte(dict1, dict2) for (dict1, dict2) in zip(dicts[1:end-1], dicts[2:end])]

paths = ParticleHolography.enum_edge(graphs[1])

for graph in graphs[2:end]
    append_path!(paths, graph)
end</code></pre><pre><code class="nohighlight hljs">julia&gt; paths[1]
5-element Vector{Base.UUID}:
 UUID(&quot;02defbf6-401e-11ef-1a7e-43a2532b2fa8&quot;)
 UUID(&quot;078214ac-401e-11ef-1a7e-43a2532b2fa8&quot;)
 UUID(&quot;0c0dcbb2-401e-11ef-1a7e-43a2532b2fa8&quot;)
 UUID(&quot;109fd490-401e-11ef-1a7e-43a2532b2fa8&quot;)
 UUID(&quot;15196216-401e-11ef-1a7e-43a2532b2fa8&quot;)</code></pre><h2 id="Trajectory-plotting"><a class="docs-heading-anchor" href="#Trajectory-plotting">Trajectory plotting</a><a id="Trajectory-plotting-1"></a><a class="docs-heading-anchor-permalink" href="#Trajectory-plotting" title="Permalink"></a></h2><p>Let&#39;s visualize the trajectories. We&#39;ll draw the trajectories using <code>paths</code> obtained in the previous section and <code>fulldict</code> obtained from the <a href="../../reference/#ParticleHolography.gen_fulldict-Tuple{Vector{Dict{Base.UUID, Vector{Float32}}}}"><code>gen_fulldict</code></a> function. Particles considered identical are drawn in the same color, while different trajectories are drawn in different colors. As there are only as many colors as there are in the palette, colors will be reused if there are more trajectories than the number of colors in the palette.</p><pre><code class="language-julia hljs">files = glob(&quot;savejson_lpf4_priter6_th24/*.json&quot;)[1:50]
fulldict = gen_fulldict(files)

trajectoryplot(paths, fulldict)</code></pre><p><img src="../../assets/trajectory.png" alt="Particle trajectories"/></p><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><div class="citation canonical"><dl><dt>[12]</dt><dd><div id="playne">D. P. Playne and K. Hawick. <em>A New Algorithm for Parallel Connected-Component Labelling on GPUs</em>. <a href="https://doi.org/10.1109/TPDS.2018.2799216">IEEE Transactions on Parallel and Distributed Systems <strong>29</strong>, 1217–1230</a> (2018).</div></dd><dt>[13]</dt><dd><div id="schanz">D. Schanz, S. Gesemann and A. Schröder. <a href="https://doi.org/10.1007/s00348-016-2157-1"><em>Shake-The-Box: Lagrangian particle tracking at high particle image densities</em></a>. <a href="https://doi.org/10.1007/s00348-016-2157-1">Experiments in Fluids <strong>57</strong>, 70</a> (2016).</div></dd><dt>[14]</dt><dd><div id="ohmi">K. Ohmi. <a href="https://www.sciencedirect.com/science/article/pii/S0096300308003688"><em>SOM-Based particle matching algorithm for 3D particle tracking velocimetry</em></a>. <a href="https://doi.org/10.1016/j.amc.2008.05.101">Applied Mathematics and Computation <strong>205</strong>, 890–898</a> (2008). Special Issue on Advanced Intelligent Computing Theory and Methodology in Applied Mathematics and Computation.</div></dd><dt>[15]</dt><dd><div id="labonte">G. Labonté. <a href="https://doi.org/10.1007/s003480050297"><em>A new neural network for particle-tracking velocimetry</em></a>. <a href="https://doi.org/10.1007/s003480050297">Experiments in Fluids <strong>26</strong>, 340–346</a> (1999).</div></dd></dl></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../pr/">« Phase retrieval holography</a><a class="docs-footer-nextpage" href="../../usage/preprocessings/">Preprocessings »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Tuesday 21 January 2025 06:20">Tuesday 21 January 2025</span>. Using Julia version 1.11.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
