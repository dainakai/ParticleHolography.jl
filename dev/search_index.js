var documenterSearchIndex = {"docs":
[{"location":"tutorials/gabor/#Gabor-holography","page":"Gabor holography","title":"Gabor holography","text":"","category":"section"},{"location":"tutorials/gabor/#gabor_reconst","page":"Gabor holography","title":"GPU-accelerated Gabor reconstruction","text":"Please refer to Gabor holography for the principles of this method. The code below is an example of performing inline holographic reconstruction using an NVIDIA GPU (CUDA.jl). Your computer needs to be ready to use NVIDIA GPUs with CUDA.jl. It reconstructs a volume of size datlenΔx x datlenΔx x slicesΔz when the camera plane is considered as the xy plane and the direction perpendicular to the camera plane, which is the optical axis, is the z axis. In this example case, it creates an xy projection image of the reconstructed volume by taking the minimum value of the z axis profile at each pixel in the xy plane of the reconstructed volume. The operation of extracting the xy projection image from the volume can be expressed by the following equation (details in cu_get_reconst_xyprojection):\n\nmathrmxyproj(x y) = min_z left mathrmrcstvol(x y z) right\n\nSpecify the hologram you want to reconstruct and the parameters, and save the projection image as xyprojection.png. \n\nusing ParticleHolography\nusing CUDA\nusing Images\n\n# Load hologram\nimg = load_gray2float(\"./test/holo1.png\")\n\n# Parameters\nλ = 0.6328 # Wavelength [μm] \nΔx = 10.0 # Pixel size [μm]\nz0 = 80000.0 # Optical distance between the hologram and the front surface of the reconstruction volume [μm]\nΔz = 100.0 # Optical distance between the reconstructed slices [μm]\ndatlen = 1024 # Data length\nslices = 1000 # Number of slices\n\n# Prepare the transfer functions\nd_sqr = cu_transfer_sqrt_arr(datlen, λ, Δx)\nd_tf = cu_transfer(-z0, datlen, λ, d_sqr)\nd_slice = cu_transfer(-Δz, datlen, λ, d_sqr)\n\n# Make a wavefront\nd_wavefront = cu_gabor_wavefront(img)\n\n# Reconstruction\nd_xyproj = cu_get_reconst_xyprojection(d_wavefront, d_tf, d_slice, slices)\n\n# Save the result\nsave(\"xyprojection_gabor.png\", Array(d_xyproj)) # Copy the d_xyproj to host memory with Array()\n\n<div style=\"display:flex; align-items:flex-start;\">\n   <div style=\"flex:1; margin-right:10px;\">\n       <img src=\"../../assets/holo.png\" alt=\"Input hologram image\" style=\"max-width:100%; height:auto;\">\n       <p style=\"text-align:center;\">Input hologram image</p>\n   </div>\n   <div style=\"flex:1;\">\n       <img src=\"../../assets/xyprojection.png\" alt=\"Output xy projection image\" style=\"max-width:100%; height:auto;\">\n       <p style=\"text-align:center;\">Output xy projection image</p>\n   </div>\n</div>","category":"section"},{"location":"tutorials/particle/#particle_handling","page":"Particle handling","title":"Particle handling","text":"This section explains the method of detecting particles from the hologram reconstruction volume, performing particle pairing on time-series data, and tracking particle trajectories.","category":"section"},{"location":"tutorials/particle/#Particle-detection","page":"Particle handling","title":"Particle detection","text":"We start by detecting particles from the reconstructed image stack of the hologram. The process begins with binarizing the reconstruction stack using a global threshold and then performing connected component labeling to create bounding boxes for the particles. Various methods and values should be considered when determining the global threshold. It's advisable to use tools like ImageJ to adjust and decide on the threshold. The cu_get_reconst_vol function returns a reconstruction stack of type N0f8 by default, which can be saved as an nrrd file using NRRD.jl and opened in Fiji as an 8-bit grayscale image stack (Tiff stack files are easier to open in ImageJ, but that process seems to be more complex). Among the binarization methods provided by these tools, the Minimum method often yields the best threshold. For time-series data, it's good to use a consistent threshold throughout the measurement series if lighting conditions remain unchanged.\n\nAlthough not shown in the following example, when working with experimental data or reconstructed images where artifacts may occur and you want to set a strict threshold, it's beneficial to use the cu_dilate function to expand the binarized volume d_bin_vol. Ideally, the particle mask d_bin_vol should cover an area slightly larger than the true particle image. This is because depth position determination methods may examine the difference between the particle image and its surroundings or utilize the gradient intensity of the particle contour. This expansion process is a normal dilation operation and is executed on the GPU, similar to the reconstruction process.\n\nThe connected component labeling applied to the binarized volume is not a strict 3D labeling in the conventional sense. First, 2D connected component labeling [12] (GPU implementation) is performed on each slice, and then elements that overlap even partially in x-y coordinates across all slices are considered identical. In other words, this process does not distinguish between different particles that overlap in x-y coordinates. As long as particles do not overlap, this method provides rough Bounding Boxes for particles and suppresses ghost particles. After completing the labeling and Bounding Box creation for all slices, we exclude those that can be considered ghost particles or are too small to observe. For more details, refer to the finalize_particle_neighborhoods! function.\n\nThe particle Bounding Boxes are provided in dictionary format. The key is a UUID, and the value is in the format [xmin, ymin, zmin, xmax, ymax, zmax]. This is used to evaluate the coordinates and size of the particles. The UUID keys assigned during the creation of Bounding Boxes are carried over to create a new dictionary, which is then returned. If only coordinates are evaluated, the key is a 3-dimensional vector; if particle size is also evaluated, it's 4-dimensional. Evaluation functions can take depth position determination methods and particle size evaluation methods as arguments. For more details, refer to the respective functions: particle_coordinates, particle_coor_diams\n\nusing ParticleHolography\nusing CUDA\n\nλ = 0.6328 # Wavelength [μm]\nΔx = 10.0 # Pixel size [μm]\nz0 = 80000.0 # Optical distance between the hologram and the front surface of the reconstruction volume [μm]\nΔz = 100.0 # Optical distance between the reconstructed slices [μm]\ndatlen = 1024 # Data length\nslices = 1000 # Number of slices\npr_dist = 80000.0 # Optical distance between the two holograms [μm]\npr_iter = 9\nthreshold = 30/255\n\nimg1 = load_gray2float(\"./holo1.png\")\nimg2 = load_gray2float(\"./holo2.png\")\n\nd_sqr = cu_transfer_sqrt_arr(datlen, λ, Δx)\nd_tf = cu_transfer(-z0, datlen, λ, d_sqr)\nd_slice = cu_transfer(-Δz, datlen, λ, d_sqr)\nd_pr = cu_transfer(pr_dist, datlen, λ, d_sqr)\nd_pr_inv = cu_transfer(-pr_dist, datlen, λ, d_sqr)\n\n# Phase retrieval using Gerchberg-Saxton algorithm\nd_holo = cu_phase_retrieval_holo(cu(img1), cu(img2), d_pr, d_pr_inv, pr_iter, datlen)\n\n# Reconstruction\nd_vol = cu_get_reconst_vol(d_holo, d_tf, d_slice, slices)\n\n# Binarization\nd_bin_vol = d_vol .<= threshold\n\nparticle_bbs = particle_bounding_boxes(d_bin_vol)\nparticle_coords = particle_coordinates(particle_bbs, d_vol)\n\n# Save the particle coordinates\ndictsave(\"particles.json\", particle_coords)","category":"section"},{"location":"tutorials/particle/#Scatter-plotting","page":"Particle handling","title":"Scatter plotting","text":"Let's plot the detected particles at each time point as a scatter plot. Since the correspondence of particles between time-series frames is still unknown at this point, we'll plot the particles at each time point in different colors. The plot recipe particleplot provided by ParticleHolography.jl is a simple arrangement of Plots.scatter(), but please note that there are differences in how the coordinate axes are handled.\n\nusing ParticleHolography\nusing Plots\nusing Glob\n\nfiles = glob(\"savejson_lpf4_priter6_th24/*.json\")[1:50]\n\ncolors = cgrad(:viridis)[LinRange(0, 1, length(files))]\nplot()\nfor (idx, file) in enumerate(files)\n    data = dictload(file)\n    particleplot!(data, legend = false, scaling=(10.0, 10.0, -100.0), shift=(0.0, 0.0, 1e5), color=colors[idx], xlabel=\"x [µm]\", ylabel=\"z [µm]\", zlabel=\"y [µm]\", xlim=(0,10240), ylim=(0,1e5), zlim=(0,10240))\nend\n\nplot!()\n\n(Image: Detected particles)","category":"section"},{"location":"tutorials/particle/#Particle-pairing","page":"Particle handling","title":"Particle pairing","text":"While overlaying detected particles from each time series creates an impactful and attractive image, what's truly crucial for many is understanding the correspondence of particle positions between time series frames. In other words, which particle in one frame corresponds to which in the next? When particle density is relatively low, a nearest neighbor approach suffices. However, as density increases, more advanced techniques become necessary. That said, particle tracking velocimetry (PTV) methods for extremely high particle densities, such as those described by [13], are unnecessary in our context. This is because hologram reconstruction becomes challenging when particle image areas exceed 20% of the x-y projection of the reconstructed image (refer to Gabor holography). ParticleHolography.jl employs an improved version of Labonté's algorithm [14, 15] for particle pairing.\n\nLabonté's algorithm elucidates the correspondence between particles in two consecutive time frames. In ParticleHolography.jl, this relationship is represented as a directed graph through the Labonte implementation. To track particles across three or more consecutive frames and obtain all trajectories, we combine these directed graphs and enumerate all paths from each starting point to each endpoint. The functions enum_edge and append_path! perform these operations.\n\nusing ParticleHolography\nusing Glob\n\n# Load the particle coordinates\nfiles = glob(\"savejson_lpf4_priter6_th24/*.json\")[1:5]\n\n# Convert to dictionary with UUID keys and Float64 values\ndicts = ParticleHolography.dictload.(files)\n\ngraphs = [Labonte(dict1, dict2) for (dict1, dict2) in zip(dicts[1:end-1], dicts[2:end])]\n\npaths = ParticleHolography.enum_edge(graphs[1])\n\nfor graph in graphs[2:end]\n    append_path!(paths, graph)\nend\n\njulia> paths[1]\n5-element Vector{Base.UUID}:\n UUID(\"02defbf6-401e-11ef-1a7e-43a2532b2fa8\")\n UUID(\"078214ac-401e-11ef-1a7e-43a2532b2fa8\")\n UUID(\"0c0dcbb2-401e-11ef-1a7e-43a2532b2fa8\")\n UUID(\"109fd490-401e-11ef-1a7e-43a2532b2fa8\")\n UUID(\"15196216-401e-11ef-1a7e-43a2532b2fa8\")","category":"section"},{"location":"tutorials/particle/#Trajectory-plotting","page":"Particle handling","title":"Trajectory plotting","text":"Let's visualize the trajectories. We'll draw the trajectories using paths obtained in the previous section and fulldict obtained from the gen_fulldict function. Particles considered identical are drawn in the same color, while different trajectories are drawn in different colors. As there are only as many colors as there are in the palette, colors will be reused if there are more trajectories than the number of colors in the palette.\n\nfiles = glob(\"savejson_lpf4_priter6_th24/*.json\")[1:50]\nfulldict = gen_fulldict(files)\n\ntrajectoryplot(paths, fulldict)\n\n(Image: Particle trajectories)","category":"section"},{"location":"tutorials/particle/#References","page":"Particle handling","title":"References","text":"D. P. Playne and K. Hawick. A New Algorithm for Parallel Connected-Component Labelling on GPUs. IEEE Transactions on Parallel and Distributed Systems 29, 1217–1230 (2018).\n\n\n\nD. Schanz, S. Gesemann and A. Schröder. Shake-The-Box: Lagrangian particle tracking at high particle image densities. Experiments in Fluids 57, 70 (2016).\n\n\n\nK. Ohmi. SOM-Based particle matching algorithm for 3D particle tracking velocimetry. Applied Mathematics and Computation 205, 890–898 (2008). Special Issue on Advanced Intelligent Computing Theory and Methodology in Applied Mathematics and Computation.\n\n\n\nG. Labonté. A new neural network for particle-tracking velocimetry. Experiments in Fluids 26, 340–346 (1999).\n\n\n\n","category":"section"},{"location":"usage/lowpassfilter/#Low-pass-filtering","page":"Low-pass filtering","title":"Low-pass filtering","text":"","category":"section"},{"location":"usage/lowpassfilter/#Introduction","page":"Low-pass filtering","title":"Introduction","text":"In [16] and other works, applying a low-pass filter to holograms is used to reduce phase distribution errors and artifacts, as well as to homogenize the reconstructed image. Furthermore, by limiting the bandwidth more strictly than the necessary and sufficient range to suppress phase undersampling, it is possible to reduce position detection errors caused by particle image elongation. Conversely, the increase in brightness of the bright-field reconstructed image due to the low-pass filter can make it difficult to determine the threshold for binarization and complicate particle size evaluation. While the effects of low-pass filtering have both advantages and disadvantages, it is often beneficial for improving certain metrics.","category":"section"},{"location":"usage/lowpassfilter/#Implementation","page":"Low-pass filtering","title":"Implementation","text":"A low-pass filter can be applied to the Fourier domain of a hologram (treated as a CuWavefront structure) by taking the Hadamard product with a NormedFloat array of the same shape (see cu_apply_low_pass_filter! and cu_apply_low_pass_filter). In ParticleHolography.jl, low-pass filters are defined by the CuLowPassFilter structure, which is defined on the GPU device. By default, a rectangular window low-pass filter cu_rectangle_filter or a super-Gaussian function (n=3) low-pass filter cu_super_gaussian_filter can be used. For determining the cutoff frequency, please refer to the function documentation or the original research papers.","category":"section"},{"location":"usage/lowpassfilter/#Example","page":"Low-pass filtering","title":"Example","text":"using ParticleHolography\nusing CUDA\nusing Images\n\n# Load hologram\nimg = load_gray2float(\"./test/holo1.png\")\n\n# Parameters\nλ = 0.6328 # Wavelength [μm] \nΔx = 10.0 # Pixel size [μm]\nz0 = 80000.0 # Optical distance between the hologram and the front surface of the reconstruction volume [μm]\nΔz = 100.0 # Optical distance between the reconstructed slices [μm]\ndatlen = 1024 # Data length\nslices = 1000 # Number of slices\n\n# Prepare the transfer functions\nd_sqr = cu_transfer_sqrt_arr(datlen, λ, Δx)\nd_tf = cu_transfer(-z0, datlen, λ, d_sqr)\nd_slice = cu_transfer(-Δz, datlen, λ, d_sqr)\n\n# Make a wavefront\nd_wavefront = cu_gabor_wavefront(img)\n\n# Apply low-pass filter\nd_lpf = cu_super_gaussian_filter(z0 + Δz * slices, λ, datlen, Δx)\ncu_apply_low_pass_filter!(d_wavefront, d_lpf)\n\n# Reconstruction\nd_xyproj = cu_get_reconst_xyprojection(d_wavefront, d_tf, d_slice, slices)","category":"section"},{"location":"usage/lowpassfilter/#References","page":"Low-pass filtering","title":"References","text":"J. P. Fugal, T. J. Schulz and R. A. Shaw. Practical methods for automated reconstruction and characterization of particles in digital in-line holograms. Measurement Science and Technology 20, 075501 (2009).\n\n\n\n","category":"section"},{"location":"tutorials/pr/#Phase-retrieval-holography","page":"Phase retrieval holography","title":"Phase retrieval holography","text":"Please refer to Phase retrieval holography for the principles of this method. Below, we show the necessary procedures and an implementation example for reconstructing using this method.","category":"section"},{"location":"tutorials/pr/#bundle_adjustment","page":"Phase retrieval holography","title":"Bundle adjustment","text":"We perform bundle adjustment [10] to correct for rotational and aberrational misalignments between the two camera views in the xyplane. First, for a pair of images with densely distributed features throughout the field of view, such as a glass plate with printed random dots, we create a vector map of displacement amounts (right figure below) by calculating the cross-correlation coefficients between neighboring batches between the two images, similar to Particle Image Velocimetry (PIV) [11]. This map represents the displacement of img2 relative to the reference image img1. By determining the image transformation coefficients bma that make this map nearly zero throughout, alignment is achieved.\n\nbeginaligned\nx = a_1 + a_2 x + a_3 y + a_4 x^2 + a_5 xy + a_6 y^2 \ny = a_7 + a_8 x + a_9 y + a_10 x^2 + a_11 xy + a_12 y^2\nendaligned\n\nPrepare a set of benchmark images, such as a glass plate with printed random dots. The following are Gabor reconstruction images of random dot holograms.\n\n<div style=\"display:flex; align-items:flex-start;\">\n   <div style=\"flex:1; margin-right:10px;\">\n       <img src=\"../../assets/impcam1_enhanced.png\" alt=\"Camera 1 image\" style=\"max-width:100%; height:auto;\">\n       <p style=\"text-align:center;\">Camera 1 image</p>\n   </div>\n   <div style=\"flex:1;\">\n       <img src=\"../../assets/impcam2_enhanced.png\" alt=\"Camera 2 image\" style=\"max-width:100%; height:auto;\">\n       <p style=\"text-align:center;\">Camera 2 image</p>\n   </div>\n</div>\n\nWe perform bundle adjustment on these images. If verbose=true is specified, the images before and after the bundle adjustment transformation and the displacement map are saved. If not specified (default is verbose=false), only the transformation coefficients are returned.\n\nusing ParticleHolography\n\n# Load images\nimg1 = load_gray2float(\"./test/impcam1_enhanced.png\")\nimg2 = load_gray2float(\"./test/impcam2_enhanced.png\")\n\n# Bundle adjustment\ncoeffs = get_distortion_coefficients(img1, img2, verbose=true)\n\n12-element Vector{Float64}:\n  1.2327552152117167\n  1.0015525820910993\n -0.0037540380646719548\n -2.6720154054315695e-7\n -3.948548695992629e-7\n  2.473601876134243e-7\n -2.168620598151057\n  0.0038907742401993704\n  1.0008643186894999\n  8.964404907592924e-8\n  7.124903769000833e-9\n  1.3007094240084437e-7\n\n(Image: Before bundle adjustment) Before bundle adjustment\n\n(Image: After bundle adjustment) After bundle adjustment\n\nUsing the coefficient array obtained in this way, we correct the distortion of the captured images.\n\nimg2_corrected = quadratic_distortion_correction(img2, coeffs)","category":"section"},{"location":"tutorials/pr/#Reconstruction","page":"Phase retrieval holography","title":"Reconstruction","text":"using ParticleHolography\nusing CUDA\nusing Images\n\n# Load hologram\nimg1 = load_gray2float(\"./test/holo1.png\")\nimg2 = load_gray2float(\"./test/holo2.png\")\n\n# Parameters\nλ = 0.6328 # Wavelength [μm] \nΔx = 10.0 # Pixel size [μm]\nz0 = 80000.0 # Optical distance between the hologram and the front surface of the reconstruction volume [μm]\nΔz = 100.0 # Optical distance between the reconstructed slices [μm]\ndatlen = 1024 # Data length\nslices = 1000 # Number of slices\n\n# Parameters for phase retrieval holography\nprz = 80000.0 # Distance between the two holograms [μm]\npriter = 20 # Number of iterations of the Gerchberg-Saxton algorithm\n\n# Prepare the transfer functions\nd_sqr = cu_transfer_sqrt_arr(datlen, λ, Δx)\nd_tf = cu_transfer(-z0, datlen, λ, d_sqr)\nd_slice = cu_transfer(-Δz, datlen, λ, d_sqr)\nd_pr = cu_transfer(prz, datlen, λ, d_sqr)\nd_pr_inv = cu_transfer(-prz, datlen, λ, d_sqr)\n\n# Image correction\nimg2_corrected = quadratic_distortion_correction(img2, coeffs)\n\n# Retrieve phase information\nd_holo = cu_phase_retrieval_holo(cu(img1), cu(img2_corrected), d_pr, d_pr_inv, priter, datlen)\n\n# Reconstruction\nd_xyproj = cu_get_reconst_xyprojection(d_holo, d_tf, d_slice, slices)\n\n# Save the result\nsave(\"xyprojection_pr.png\", Array(d_xyproj)) # Copy the d_xyproj to host memory with Array()\n\n<div style=\"display:flex; align-items:flex-start;\">\n   <div style=\"flex:1; margin-right:10px;\">\n       <img src=\"../../assets/holo.png\" alt=\"Input hologram image\" style=\"max-width:100%; height:auto;\">\n       <p style=\"text-align:center;\">Input hologram image</p>\n   </div>\n   <div style=\"flex:1;\">\n       <img src=\"../../assets/xyprojection_pr.png\" alt=\"Output xy projection image\" style=\"max-width:100%; height:auto;\">\n       <p style=\"text-align:center;\">Output xy projection image</p>\n   </div>\n</div>","category":"section"},{"location":"tutorials/pr/#References","page":"Phase retrieval holography","title":"References","text":"岡谷貴之. バンドルアジャストメント. 研究報告コンピュータビジョンとイメージメディア (CVIM) 2009–37, 1–16 (2009).\n\n\n\nC. E. Willert and M. Gharib. Digital particle image velocimetry. Experiments in Fluids 10–4, 181–193 (1991).\n\n\n\n","category":"section"},{"location":"usage/reconstruction/#Reconstruction","page":"Volume reconstruction","title":"Reconstruction","text":"We assume that the necessary preprocessing has been completed and an array of type ParticleHolography.CuWaveFront, d_wavefront, has been obtained. Using this array, we perform a 3D reconstruction of the observed volume. In Gabor holography, we have already described the functions for obtaining the projection images in the optical axis direction of the observed volume. In addition to this, depending on the required information, you can select the following reconstruction functions.","category":"section"},{"location":"usage/reconstruction/#ParticleHolography.cu_get_reconst_xyprojection","page":"Volume reconstruction","title":"ParticleHolography.cu_get_reconst_xyprojection","text":"cu_get_reconst_xyprojectin(wavefront, transfer_front, transfer_dz, slices)\n\nGet the XY projection of the reconstructed volume from the wavefront using the transfer functions transfer_front and transfer_dz. transfer_front propagates the wavefront to the front of the volume, and transfer_dz propagates the wavefront between the slices. slices is the number of slices in the volume.\n\nArguments\n\nwavefront::CuWavefront{ComplexF32}: The wavefront to reconstruct. In Gabor's holography, this is the square root of the hologram.\ntransfer_front::CuTransfer{ComplexF32}: The transfer function to propagate the wavefront to the front of the volume. See CuTransfer.\ntransfer_dz::CuTransfer{ComplexF32}: The transfer function to propagate the wavefront between the slices.\nslices::Int: The number of slices in the volume.\n\nReturns\n\nCuArray{Float32,2}: The XY projection of the reconstructed volume.\n\n\n\n\n\n","category":"function"},{"location":"usage/reconstruction/#ParticleHolography.cu_get_reconst_vol","page":"Volume reconstruction","title":"ParticleHolography.cu_get_reconst_vol","text":"cu_get_reconst_vol(holo, transfer_front, transfer_dz, slices, return_type)\n\nReconstruct the observation volume from the wavefront using the transfer functions transfer_front and transfer_dz. transfer_front propagates the wavefront to the front of the volume, and transfer_dz propagates the wavefront between the slices. slices is the number of slices in the volume.\n\nArguments\n\nwavefront::CuArray{ComplexF32,2}: The wavefront to reconstruct. In Gabor's holography, this is the square root of the hologram.\ntransfer_front::CuTransfer{ComplexF32}: The transfer function to propagate the wavefront to the front of the volume. See CuTransfer.\ntransfer_dz::CuTransfer{ComplexF32}: The transfer function to propagate the wavefront between the slices.\nslices::Int: The number of slices in the volume.\nreturn_type::Type: The return type of the reconstructed volume. Default is N0f8.\n\nReturns\n\nCuArray{return_type,3}: The reconstructed intensity volume.\n\n\n\n\n\n","category":"function"},{"location":"usage/reconstruction/#ParticleHolography.cu_get_reconst_complex_vol","page":"Volume reconstruction","title":"ParticleHolography.cu_get_reconst_complex_vol","text":"cu_get_reconst_complex_vol(holo, transfer_front, transfer_dz, slices)\n\nReconstruct the observation volume from the wavefront using the transfer functions transfer_front and transfer_dz and return the complex amplitude volume. transfer_front propagates the wavefront to the front of the volume, and transfer_dz propagates the wavefront between the slices. slices is the number of slices in the volume.\n\nArguments\n\nwavefront::CuArray{ComplexF32,2}: The wavefront to reconstruct. In Gabor's holography, this is the square root of the hologram.\ntransfer_front::CuTransfer{ComplexF32}: The transfer function to propagate the wavefront to the front of the volume. See CuTransfer.\ntransfer_dz::CuTransfer{ComplexF32}: The transfer function to propagate the wavefront between the slices.\nslices::Int: The number of slices in the volume.\n\nReturns\n\nCuArray{ComplexF32,3}: The reconstructed complex amplitude volume.\n\n\n\n\n\n","category":"function"},{"location":"usage/reconstruction/#ParticleHolography.cu_get_reconst_vol_and_xyprojection","page":"Volume reconstruction","title":"ParticleHolography.cu_get_reconst_vol_and_xyprojection","text":"cu_get_reconst_vol_and_xyprojection(wavefront, transfer_front, transfer_dz, slices, return_type)\n\nReconstruct the observation volume from the wavefront and get the XY projection of the volume using the transfer functions transfer_front and transfer_dz. transfer_front propagates the wavefront to the front of the volume, and transfer_dz propagates the wavefront between the slices. slices is the number of slices in the volume.\n\nArguments\n\nwavefront::CuWavefront{ComplexF32}: The wavefront to reconstruct. In Gabor's holography, this is the square root of the hologram.\ntransfer_front::CuTransfer{ComplexF32}: The transfer function to propagate the wavefront to the front of the volume. See CuTransfer.\ntransfer_dz::CuTransfer{ComplexF32}: The transfer function to propagate the wavefront between the slices.\nslices::Int: The number of slices in the volume.\nreturn_type::Type: The return type of the reconstructed volume. Default is N0f8.\n\nReturns\n\nCuArray{return_type,3}: The reconstructed volume.\nCuArray{Float32,2}: The XY projection of the reconstructed volume.\n\n\n\n\n\n","category":"function"},{"location":"whats_inline_holography/#Gabor's-inline-holography","page":"What's inline holography?","title":"Gabor's inline holography","text":"","category":"section"},{"location":"whats_inline_holography/#introduction","page":"What's inline holography?","title":"Introduction","text":"Holography is an imaging and measurement technique first proposed by D. Gabor in 1948 [1]. The interference pattern between the object light, which is diffracted by obstacles such as particles, and a reference light is recorded on a photosensitive material like a film, which is called a hologram. When the hologram is illuminated with a reconstruction light, the original light field is partially reproduced. In the case of small opaque objects like particles, the reconstructed light field is obstructed at the particle positions, appearing as dark images in the reconstruction. This allows the 3D position and shape of the objects to be observed. Currently, photosensitive materials have been replaced by digital cameras, and hologram reconstruction is commonly performed using digital image processing techniques such as numerical light propagation calculations. In an in-line holography setup, the coherent parallel light, the object observation volume, and the camera plane are all arranged along the same axis, eliminating the need to separate the object and reference light, and simplifying the reconstruction calculation. This article explains the light propagation calculation for parallel light, hologram recording and reconstruction, and the phase retrieval method, which is an advanced technique derived from Gabor holography.\n\n(Image: holography)","category":"section"},{"location":"whats_inline_holography/#Collimated-light-propagation","page":"What's inline holography?","title":"Collimated light propagation","text":"The propagation of parallel light follows the Helmholtz equation and can be calculated quickly and accurately using the angular spectrum method [2] [3]. Defining the optical axis of the parallel light as the z axis and the plane perpendicular to it as the xy plane, the wavefront of the parallel light at z=z_0 is denoted as psi(x y z_0). The light field propagated by Delta z in the positive z direction is given by the following equation:\n\npsi(xyz_0 + Delta z) = mathcalF^-1left mathcalFpsi(xyz_0) cdot expleft( fracmathrmj2pi Delta zlambda sqrt1-left( lambda alpha right)^2 - left( lambda beta right)^2 right) right\n\nHere, mathcalF denotes the two-dimensional Fourier transform, alpha beta are the Fourier domain variables corresponding to xy, and lambda is the wavelength. This equation shows that by Fourier transforming the wavefront of the parallel light, multiplying it by the transfer function H_Delta z=expleft( fracmathrmj2pi Delta zlambda sqrt1-left( lambda alpha right)^2 - left( lambda beta right)^2 right), and then performing an inverse Fourier transform, the light field propagated by Delta z in the positive z direction can be obtained.","category":"section"},{"location":"whats_inline_holography/#Hologram-recording-(Computer-generated-holography)","page":"What's inline holography?","title":"Hologram recording (Computer generated holography)","text":"Holography is a technique for reconstructing 3D images from obtained holograms, but it is also possible to numerically generate holograms by modeling the objects and their arrangements. Generally, an opaque particle with radius r_0 located at (x_0y_0z_0) can be treated as a circular disk with zero thickness on the object plane x_0-y_0 [4]. The object plane A_0 is represented as follows:\n\nA_0(xy) = begincases\n1  textif quad (x-x_0)^2 + (y-y_0)^2 leq r_0^2 \n0  textotherwise\nendcases\n\nThe diffraction pattern of the particle appears on the hologram as the parallel light is blocked at the points where the object plane has a value of 1. The hologram can be calculated using the following equation:\n\nI(xy z_0+Delta z) = left mathcalF^-1left mathcalFpsi(xyz_0)cdot left(1-A_0right) cdot H_Delta z right right^2\n\n\\psi(x,y;z_0) is the wavefront of the parallel light just before passing through the object plane. If no objects exist before this point, the phase at each point can be set to 0, and we can assume psi(xyz_0)=1. Even if objects exist before this point, we can calculate the light field propagated from the position of the farthest particle by setting the phase there to 0 and using the same method as in the above equation. Since the hologram is the intensity distribution of the light field, it is represented by the square of the amplitude of the wavefront. The light field is a complex number, so this calculation involves taking the product with its complex conjugate.","category":"section"},{"location":"whats_inline_holography/#gabor_explain","page":"What's inline holography?","title":"Hologram reconstruction (Gabor holography)","text":"It is possible to reconstruct a hologram by directly propagating the intensity distribution of the light field, which is the hologram, in the negative z direction [4]. However, to maintain consistency with the phase retrieval method, which will be explained later, the reconstructed wavefront is taken as the square root of the hologram.\n\npsi(xyz_0) = mathcalF^-1left mathcalFsqrtI(xyz_0+Delta z) cdot expleft( frac-mathrmj2pi Delta zlambda sqrt1-left( lambda alpha right)^2 - left( lambda beta right)^2 right) right\n\nGenerally, the particle positions are unknown during reconstruction. By varying the reconstruction distance -Delta z throughout the observation volume, the particle positions within the volume can be determined. In practice, the wavefront is first propagated to the front surface of the observation volume closest to the camera using the transfer function for the distance to this surface. Then, transfer functions with finer reconstruction intervals are generated, and the wavefront is propagated at each interval to create z-direction slices of the observation volume. This approach requires the generation of only two transfer functions.","category":"section"},{"location":"whats_inline_holography/#Twin-image-problem","page":"What's inline holography?","title":"Twin image problem","text":"In the hologram reconstruction equation above, the square root of the hologram is treated as the light field at that point, which naturally leads to the loss of phase information from the hologram. Consequently, the intensity of the reconstructed particle images does not match the values of the transmission function (defined as (1 - object plane)). For more details on these issues, refer to [5] and [6].\n\n(Image: gabor reconstruction) Gabor reconstruction and its intensity profile\n\nIf the phase information of the hologram could be restored to obtain an ideal reconstruction, as shown below, the threshold for particle detection could be lowered, resulting in improved particle detection performance. In the figure below, the restoration of phase information eliminates the conjugate image in the reconstruction, and the profile closely matches the correct transmission function plot.\n\n(Image: phase retrieval) Phase retrieved reconstruction and its intensity profile\n\nThe method that achieves this is phase retrieval holography [7] using the Gerchberg-Saxton algorithm [8].","category":"section"},{"location":"whats_inline_holography/#pr_explain","page":"What's inline holography?","title":"Phase retrieval holography","text":"Phase retrieval holography is a technique for reconstructing the optical wavefront, including phase information, from a pair of simultaneous holograms captured at two points separated by a propagation distance Delta z_p from the object. Let's denote the hologram closer to the object plane as I_1 and the other as I_2. Using the same indexing, we define the optical wavefront psi and its phase distribution phi. The following iterative operation (Gerchberg-Saxton algorithm) is repeated for the two holograms:","category":"section"},{"location":"whats_inline_holography/#Initial-condition","page":"What's inline holography?","title":"Initial condition","text":"phi_1 = 0 quad psi_1 = sqrtI_1 expleft( mathrmjphi_1 right)","category":"section"},{"location":"whats_inline_holography/#STEP-1","page":"What's inline holography?","title":"STEP 1","text":"psi_2 = mathcalF^-1left mathcalFpsi_1 cdot H_Delta z_p right \nphi_2 = argleft mathcalFpsi_2 right\n\nThe wavefront psi_1 is propagated by the hologram separation distance Delta z_p to calculate the wavefront psi_2, and its argument is saved as the phase distribution phi_2.","category":"section"},{"location":"whats_inline_holography/#STEP-2","page":"What's inline holography?","title":"STEP 2","text":"psi_2 = sqrtI_2 expleft( mathrmjphi_2 right)\n\nThe wavefront psi_2 is redefined by the square root of the hologram I_2 and the phase distribution phi_2.","category":"section"},{"location":"whats_inline_holography/#STEP-3","page":"What's inline holography?","title":"STEP 3","text":"psi_1 = mathcalF^-1left mathcalFpsi_2 cdot H_-Delta z_p right \nphi_1 = argleft mathcalFpsi_1 right\n\nThe wavefront psi_2is back-propagated by the hologram separation distance Delta z_p to calculate the wavefront psi_1, and its argument is saved as the phase distribution phi_1.","category":"section"},{"location":"whats_inline_holography/#STEP-4","page":"What's inline holography?","title":"STEP 4","text":"psi_1 = sqrtI_1 expleft( mathrmjphi_1 right)\n\nThe wavefront psi_1 is redefined by the square root of the hologram I_1 and the phase distribution phi_1.\n\nFor details such as the number of iterations of the above algorithm and camera arrangement, please refer to the literature such as [9].","category":"section"},{"location":"whats_inline_holography/#References","page":"What's inline holography?","title":"References","text":"D. Gabor. A new microscopic principle. Nature 161, 777–778 (1948).\n\n\n\nJ. W. Goodman. Introduction to Fourier Optics –3rd ed. (Roberts and Company publishers, 2005); pp. 42–62.\n\n\n\nM. A. T. M. Kreis and W. P. Jüptner. Methods of digital holography: a comparison. In Optical Inspection and Micromeasurements II, SPIE 3098, 224–233 (1997).\n\n\n\nC. S. Vikram. Particle Field Holography (Cambridge University Press, 1992); p. 34.\n\n\n\nJ. Katz and J. Sheng. Applications of holography in fluid mechanics and particle dynamics. Annual Review of Fluid Mechanics 42, 531–555 (2010).\n\n\n\nH. Meng and F. Hussain. In-line recording and off-axis viewing technique for holographic particle velocimetry. Applied Optics 34–11, 1827–1840 (1995).\n\n\n\nG. Liu and P. Scott. Phase retrieval and twin-image elimination for in-line Fresnel holograms. Journal of the Optical Society of America A 4–1, 159–165 (1987).\n\n\n\nR. W. Gerchberg and W. O. Saxton. A practical algorithm for the determination of phase from image and diffraction plane pictures. Optik 35–2, 237–246 (1972).\n\n\n\nY. Tanaka, S. Tani and S. Murata. Phase retrieval method for digital holography with two cameras in particle measurement. Optics Express 24–22, 25233–25241 (2016).\n\n\n\n","category":"section"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"This is the reference documentation for the ParticleHolography package.","category":"section"},{"location":"reference/#Index","page":"Reference","title":"Index","text":"Pages = [\"reference.md\"]","category":"section"},{"location":"reference/#Types-and-Functions","page":"Reference","title":"Types and Functions","text":"","category":"section"},{"location":"reference/#ParticleHolography.CuLowPassFilter","page":"Reference","title":"ParticleHolography.CuLowPassFilter","text":"CuLowPassFilter{T<: AbstractFloat}\n\nA struct that holds the data for the low pass filter. This can be multiplied with the Fourier transform of wavefront to get the low pass filtered wavefront after propagation.\n\nFields\n\ndata::CuArray{T,2}: The data for the low pass filter.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ParticleHolography.CuTransfer","page":"Reference","title":"ParticleHolography.CuTransfer","text":"CuTransfer{T<: Complex}\n\nA struct that holds the data for the transfer function.\n\nFields\n\ndata::CuArray{T,2}: The data for the transfer function.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ParticleHolography.CuTransferSqrtPart","page":"Reference","title":"ParticleHolography.CuTransferSqrtPart","text":"CuTransferSqrtPart{T<: AbstractFloat}\n\nA struct that holds the data for the square root part of the transfer function.\n\nFields\n\ndata::CuArray{T,2}: The data for the square root part of the transfer function.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ParticleHolography.CuWavefront","page":"Reference","title":"ParticleHolography.CuWavefront","text":"CuWavefront{T<: Complex}\n\nA struct that holds the data for the wavefront.\n\nFields\n\ndata::CuArray{T,2}: The data for the wavefront.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ParticleHolography.Labonte-Tuple{Any, Any}","page":"Reference","title":"ParticleHolography.Labonte","text":"Labonte(dict1, dict2; Dmax=50.0, α=0.005, R=50.0, Rend=0.1, β=0.9, N=10)\n\nImplementation of the improved Labonté algorithm [14, 15]. Takes dictionaries of detected particle coordinates at two time points as input and returns a graph representing the correspondence between particles at these two time points. The graph contains UUID keys of all particles from both time points as nodes, with directed edges representing particle correspondences from particles in dict1 to particles in dict2. All correspondences can be retrieved using the enum_edge function.\n\nArguments\n\ndict1::Dict{UUID, Vector{Float32}}: Dictionary of detected particle coordinates at the first time point.\ndict2::Dict{UUID, Vector{Float32}}: Dictionary of detected particle coordinates at the second time point.\n\nOptional keyword arguments\n\nDmax::Float32=50.0: Maximum allowable movement distance.\nα::Float32=0.005: Learning rate.\nR::Float32=50.0: Initial value of the inspection neighborhood radius.\nRend::Float32=0.1: Final value of the inspection neighborhood radius. The algorithm terminates when the inspection radius becomes smaller than this value through iterations.\nβ::Float32=0.9: Decay rate of the inspection neighborhood radius.\nN::Int=10: Nodes that are not selected as winners for N consecutive times are removed. Refer to the original paper for details.\ndim3weight::Float32=0.01: Scaling factor for the third dimension. For holographic particle tracking, the third dimension is often less accurate than the first two dimensions, so it is scaled down.\n\nReturns\n\nMetaGraph: Graph representing the correspondence between detected particles at two time points.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ParticleHolography.append_path!-Tuple{Any, MetaGraphsNext.MetaGraph}","page":"Reference","title":"ParticleHolography.append_path!","text":"append_path!(paths, g::MetaGraph)\n\nAdds correspondences from the MetaGraph g to the trajectory array paths initialized by the enum_edge function. Specifically, if the last element of a Vector{UUID} array path in paths matches the starting point of an edge in g, the endpoint of that edge is appended to paths. If the graph is not injective, path is duplicated.\n\nArguments\n\npaths::Vector{UUID}[]: Array of trajectories.\ng::MetaGraph: The MetaGraph from which correspondences are to be added.\n\nReturns\n\nnothing\n\n\n\n\n\n","category":"method"},{"location":"reference/#ParticleHolography.cu_2d_pad-Tuple{Any}","page":"Reference","title":"ParticleHolography.cu_2d_pad","text":"cu_2d_pad(inarr)\n\nPad the 2D CuArray inarr with its mean value to double its size in both dimensions.\n\nArguments\n\ninarr::CuArray{ComplexF32,2}: The input 2D CuArray to be padded.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ParticleHolography.cu_apply_low_pass_filter!-Tuple{CuWavefront, CuLowPassFilter}","page":"Reference","title":"ParticleHolography.cu_apply_low_pass_filter!","text":"cu_apply_low_pass_filter!(holo, lpf)\n\nApply a low pass filter to the wavefront holo. The low pass filter is applied by multiplying the Fourier transform of the wavefront with the Fourier transform of the low pass filter. The wavefront is then reconstructed by taking the inverse Fourier transform of the filtered Fourier transform.\n\nArguments\n\nholo::CuWavefront: The wavefront to apply the low pass filter.\nlpf::CuLowPassFilter: The low pass filter to apply to the wavefront.\n\nReturns\n\nnothing\n\n\n\n\n\n","category":"method"},{"location":"reference/#ParticleHolography.cu_apply_low_pass_filter-Tuple{CuWavefront, CuLowPassFilter}","page":"Reference","title":"ParticleHolography.cu_apply_low_pass_filter","text":"cu_apply_low_pass_filter(holo, lpf)\n\nApply a low pass filter to the wavefront holo. The low pass filter is applied by multiplying the Fourier transform of the wavefront with the Fourier transform of the low pass filter. The wavefront is then reconstructed by taking the inverse Fourier transform of the filtered Fourier transform.\n\nArguments\n\nholo::CuWavefront: The wavefront to apply the low pass filter.\nlpf::CuLowPassFilter: The low pass filter to apply to the wavefront.\n\nReturns\n\nCuWavefront{ComplexF32}: The wavefront after applying the low pass filter.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ParticleHolography.cu_asm_prop!-Tuple{CuWavefront, CuWavefront, CuTransferSqrtPart, Float64, Int64, Float64}","page":"Reference","title":"ParticleHolography.cu_asm_prop!","text":"cu_asm_prop!(outholo, inholo, d_sqr, zprop, datlen, λ)\n\nPerform angular spectrum method-based propagation of the wavefront inholo by distance zprop and store the result in outholo. d_sqr is the square-root part of the transfer function obtained with cutransfersqrtarr(datlen, λ, dx). datlen is the size of the holograms, and λ is the wavelength of the light.\n\nArguments\n\noutholo::CuWavefront{ComplexF32}: The output wavefront after propagation. See CuWavefront.\ninholo::CuWavefront{ComplexF32}: The input wavefront to propagate. See CuWavefront.\nd_sqr::CuTransferSqrtPart{Float32}: The square-root part of the transfer function obtained with cutransfersqrtarr(datlen, λ, dx). See [CuTransferSqrtPart`](@ref).\nzprop::Float64: The distance to propagate the wavefront.\ndatlen::Int: The size of the holograms.\nλ::Float64: The wavelength of the light.\n\nReturns\n\nNothing: The result is stored in outholo.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ParticleHolography.cu_connected_component_labeling-Tuple{Any}","page":"Reference","title":"ParticleHolography.cu_connected_component_labeling","text":"cu_connected_component_labeling(input_img)\n\n8-way connected component labeling on binary image based on the article by Playne and Hawick https://ieeexplore.ieee.org/document/8274991 and the implementation by FolkeV https://github.com/FolkeV/CUDA_CCL. It works using the CUDA.jl package and NVIDIA GPUs.\n\nArguments\n\ninput_img::CuArray{Float32, 2}: Input binary image. \n\nReturns\n\noutput_img::CuArray{UInt32, 2}: Output labeled image.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ParticleHolography.cu_dilate-Tuple{CUDA.CuArray{Bool, 3}}","page":"Reference","title":"ParticleHolography.cu_dilate","text":"cu_dilate(vol; blocksize=32)\n\nPerform a 3D dilation on the reconstructed image stack vol and return the dilated stack.\n\nArguments\n\nvol::CuArray{Bool,3}: The input 3D binary volume to be dilated. It can be the result of thresholding a reconstructed volume.\nblocksize::Int: The block size for CUDA kernel execution. Default is 32.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ParticleHolography.cu_gabor_wavefront-Tuple{CUDA.CuArray{Float32, 2}}","page":"Reference","title":"ParticleHolography.cu_gabor_wavefront","text":"cu_gabor_wavefront(holo)\n\nCreate a wavefront from single hologram holo. This is for Gabor holography. The wavefront is created by taking the square root of the hologram and casting it to a complex number.\n\nArguments\n\nholo::CuArray{Float32,2}: The hologram to create the wavefront from.\n\nReturns\n\nCuWavefront{ComplexF32}: The wavefront created from the hologram. See CuWavefront.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ParticleHolography.cu_get_reconst_complex_vol-Tuple{CuWavefront{ComplexF32}, CuTransfer{ComplexF32}, CuTransfer{ComplexF32}, Int64}","page":"Reference","title":"ParticleHolography.cu_get_reconst_complex_vol","text":"cu_get_reconst_complex_vol(holo, transfer_front, transfer_dz, slices)\n\nReconstruct the observation volume from the wavefront using the transfer functions transfer_front and transfer_dz and return the complex amplitude volume. transfer_front propagates the wavefront to the front of the volume, and transfer_dz propagates the wavefront between the slices. slices is the number of slices in the volume.\n\nArguments\n\nwavefront::CuArray{ComplexF32,2}: The wavefront to reconstruct. In Gabor's holography, this is the square root of the hologram.\ntransfer_front::CuTransfer{ComplexF32}: The transfer function to propagate the wavefront to the front of the volume. See CuTransfer.\ntransfer_dz::CuTransfer{ComplexF32}: The transfer function to propagate the wavefront between the slices.\nslices::Int: The number of slices in the volume.\n\nReturns\n\nCuArray{ComplexF32,3}: The reconstructed complex amplitude volume.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ParticleHolography.cu_get_reconst_vol","page":"Reference","title":"ParticleHolography.cu_get_reconst_vol","text":"cu_get_reconst_vol(holo, transfer_front, transfer_dz, slices, return_type)\n\nReconstruct the observation volume from the wavefront using the transfer functions transfer_front and transfer_dz. transfer_front propagates the wavefront to the front of the volume, and transfer_dz propagates the wavefront between the slices. slices is the number of slices in the volume.\n\nArguments\n\nwavefront::CuArray{ComplexF32,2}: The wavefront to reconstruct. In Gabor's holography, this is the square root of the hologram.\ntransfer_front::CuTransfer{ComplexF32}: The transfer function to propagate the wavefront to the front of the volume. See CuTransfer.\ntransfer_dz::CuTransfer{ComplexF32}: The transfer function to propagate the wavefront between the slices.\nslices::Int: The number of slices in the volume.\nreturn_type::Type: The return type of the reconstructed volume. Default is N0f8.\n\nReturns\n\nCuArray{return_type,3}: The reconstructed intensity volume.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ParticleHolography.cu_get_reconst_vol_and_xyprojection","page":"Reference","title":"ParticleHolography.cu_get_reconst_vol_and_xyprojection","text":"cu_get_reconst_vol_and_xyprojection(wavefront, transfer_front, transfer_dz, slices, return_type)\n\nReconstruct the observation volume from the wavefront and get the XY projection of the volume using the transfer functions transfer_front and transfer_dz. transfer_front propagates the wavefront to the front of the volume, and transfer_dz propagates the wavefront between the slices. slices is the number of slices in the volume.\n\nArguments\n\nwavefront::CuWavefront{ComplexF32}: The wavefront to reconstruct. In Gabor's holography, this is the square root of the hologram.\ntransfer_front::CuTransfer{ComplexF32}: The transfer function to propagate the wavefront to the front of the volume. See CuTransfer.\ntransfer_dz::CuTransfer{ComplexF32}: The transfer function to propagate the wavefront between the slices.\nslices::Int: The number of slices in the volume.\nreturn_type::Type: The return type of the reconstructed volume. Default is N0f8.\n\nReturns\n\nCuArray{return_type,3}: The reconstructed volume.\nCuArray{Float32,2}: The XY projection of the reconstructed volume.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ParticleHolography.cu_get_reconst_vol_and_xyprojection_padded","page":"Reference","title":"ParticleHolography.cu_get_reconst_vol_and_xyprojection_padded","text":"cu_get_reconst_vol_and_xyprojection_padded(wavefront, transfer_front, transfer_dz, slices, return_type)\n\nReconstruct the observation volume from the padded wavefront and get the XY projection of the volume using the transfer functions transfer_front and transfer_dz. transfer_front propagates the wavefront to the front of the volume, and transfer_dz propagates the wavefront between the slices. slices is the number of slices in the volume.\n\nArguments\n\nwavefront::CuWavefront{ComplexF32}: The wavefront to reconstruct. In Gabor's holography, this is the square root of the hologram.\ntransfer_front::CuTransfer{ComplexF32}: The transfer function to propagate the wavefront to the front of the volume. See CuTransfer.\ntransfer_dz::CuTransfer{ComplexF32}: The transfer function to propagate the wavefront between the slices.\nslices::Int: The number of slices in the volume.\nreturn_type::Type: The return type of the reconstructed volume. Default is N0f8.\n\nReturns\n\nCuArray{return_type,3}: The reconstructed volume.\nCuArray{Float32,2}: The XY projection of the reconstructed volume.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ParticleHolography.cu_get_reconst_xyprojection-Tuple{CuWavefront{ComplexF32}, CuTransfer{ComplexF32}, CuTransfer{ComplexF32}, Int64}","page":"Reference","title":"ParticleHolography.cu_get_reconst_xyprojection","text":"cu_get_reconst_xyprojectin(wavefront, transfer_front, transfer_dz, slices)\n\nGet the XY projection of the reconstructed volume from the wavefront using the transfer functions transfer_front and transfer_dz. transfer_front propagates the wavefront to the front of the volume, and transfer_dz propagates the wavefront between the slices. slices is the number of slices in the volume.\n\nArguments\n\nwavefront::CuWavefront{ComplexF32}: The wavefront to reconstruct. In Gabor's holography, this is the square root of the hologram.\ntransfer_front::CuTransfer{ComplexF32}: The transfer function to propagate the wavefront to the front of the volume. See CuTransfer.\ntransfer_dz::CuTransfer{ComplexF32}: The transfer function to propagate the wavefront between the slices.\nslices::Int: The number of slices in the volume.\n\nReturns\n\nCuArray{Float32,2}: The XY projection of the reconstructed volume.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ParticleHolography.cu_make_background_mode-Tuple{Any}","page":"Reference","title":"ParticleHolography.cu_make_background_mode","text":"cu_make_background_mode(grayimglist)\n\nCompute the per-pixel intensity mode from the list returned by load_grayimg() and return it as a background image. The computation uses CUDA.\n\nArguments\n\ngrayimglist::Vector{Array{N0f8, 2}}: A list of grayscale images as Array{N0f8, 2}.\n\nReturns\n\nArray{Float64, 2}: The background image.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ParticleHolography.cu_phase_retrieval_holo-Tuple{CUDA.CuArray{Float32, 2}, CUDA.CuArray{Float32, 2}, CuTransfer{ComplexF32}, CuTransfer{ComplexF32}, Int64, Int64}","page":"Reference","title":"ParticleHolography.cu_phase_retrieval_holo","text":"cu_phase_retrieval_holo(holo1, holo2, transfer, invtransfer, priter, datlen)\n\nPerform the Gerchberg-Saxton algorithm-based phase retrieving on two holograms and return the retrieved wavefront at the z-coordinate point of holo1. The algorithm is repeated priter times. holo1 and holo2 are the holograms (I = |phi|^2) of the object at two different z-coordinates. transfer and invtransfer are the transfer functions for the propagation from holo1 to holo2 and vice versa. datlen is the size of the holograms.\n\nArguments\n\nholo1::CuArray{Float32,2}: The hologram at the z-cordinate of closer to the object.\nholo2::CuArray{Float32,2}: The hologram at the z-coordinate of further from the object.\ntransfer::CuTransfer{ComplexF32}: The transfer function from holo1 to holo2.\ninvtransfer::CuTransfer{ComplexF32}: The transfer function from holo2 to holo1.\npriter::Int: The number of iterations to perform the algorithm.\ndatlen::Int: The size of the holograms.\n\nReturns\n\nCuWavefront{ComplexF32}: The retrieved wavefront at the z-coordinate of holo1. See CuWavefront.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ParticleHolography.cu_rectangle_filter-Tuple{AbstractFloat, AbstractFloat, Int64, AbstractFloat}","page":"Reference","title":"ParticleHolography.cu_rectangle_filter","text":"cu_rectangle_filter(prop_dist::AbstractFloat, wavlen::AbstractFloat, imglen::Int, pixel_picth::AbstractFloat)\n\nCreates a low pass filter with a rectangular window. This can be multiplied with the Fourier transform of wavefront to get the low pass filtered wavefront. See Eq. 13 and 14 in (Fugal, 2009, https://doi.org/10.1088/0957-0233/20/7/075501)\n\nArguments\n\nprop_dist::AbstractFloat: The maximum propagation distance of recorded objects.\nwavlen::AbstractFloat: The wavelength of the light.\nimglen::Int: The length of the image.\npixel_picth::AbstractFloat: The pixel pitch of the image.\n\nReturns\n\nCuLowPassFilter: The low pass filter as a CuLowPassFilter object.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ParticleHolography.cu_super_gaussian_filter-Tuple{AbstractFloat, AbstractFloat, Int64, AbstractFloat}","page":"Reference","title":"ParticleHolography.cu_super_gaussian_filter","text":"cu_super_gaussian_filter(prop_dist::AbstractFloat, wavlen::AbstractFloat, imglen::Int, pixel_picth::AbstractFloat)\n\nCreates a low pass filter with a super Gaussian window. This can be multiplied with the Fourier transform of wavefront to get the low pass filtered wavefront. See Eq. 15 in (Fugal, 2009, https://doi.org/10.1088/0957-0233/20/7/075501)\n\nArguments\n\nprop_dist::AbstractFloat: The maximum propagation distance of recorded objects.\nwavlen::AbstractFloat: The wavelength of the light.\nimglen::Int: The length of the image.\npixel_picth::AbstractFloat: The pixel pitch of the image.\n\nReturns\n\nCuLowPassFilter: The low pass filter as a CuLowPassFilter object.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ParticleHolography.cu_transfer-Tuple{AbstractFloat, Int64, AbstractFloat, CuTransferSqrtPart{Float32}}","page":"Reference","title":"ParticleHolography.cu_transfer","text":"cu_transfer(z0, datLen, wavLen, d_sqr)\n\nCreate a CuArray of size datLen x datLen with the values of the transfer function for a given propagated distance z0. d_sqr can be obtained with cutransfersqrtarr(datlen, wavlen, dx).\n\nArguments\n\nz0::AbstractFloat: The distance to propagate the wave.\ndatLen::Int: The size of the CuArray.\nwavLen::AbstractFloat: The wavelength of the light.\nd_sqr::::CuTransferSqrtPart{Float32}: The square of the distance from the center of the hologram, obtained with cutransfersqrtarr(datlen, wavlen, dx).\n\nReturns\n\nCuTransfer{Float32}: The transfer function for the propagation. See CuTransfer.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ParticleHolography.cu_transfer_sqrt_arr-Tuple{Int64, AbstractFloat, AbstractFloat}","page":"Reference","title":"ParticleHolography.cu_transfer_sqrt_arr","text":"cu_transfer_sqrt_arr(datlen, wavlen, dx)\n\nCreate a CuArray of size datlen x datlen with the values of the square-root part of the transfer function.\n\nArguments\n\ndatlen::Int: The size of the CuArray.\nwavlen::AbstractFloat: The wavelength of the light.\ndx::AbstractFloat: The pixel size of the hologram.\n\nReturns\n\nCuTransferSqrtPart{Float32}: The square-root part of the transfer function. See CuTransferSqrtPart.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ParticleHolography.dictload-Tuple{Any}","page":"Reference","title":"ParticleHolography.dictload","text":"dictload(filename)\n\nLoad a particle dictionary from a file in JSON format. The dictionary should have UUID keys and values as Vector{Float32}, which includes the coordinates (and diameters) of the particles.\n\nArguments\n\nfilename::String: The path to the file.\n\nReturns\n\nDict: The loaded dictionary.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ParticleHolography.dictsave-Tuple{Any, Dict}","page":"Reference","title":"ParticleHolography.dictsave","text":"dictsave(filename, dict)\n\nSave a particle dictionary to a file in JSON format. The dictionary should have UUID keys and values as Vector{Float32}, which includes the coordinates (and diameters) of the particles.\n\nArguments\n\nfilename::String: The path to the file.\ndict::Dict: The dictionary to save.\n\nReturns\n\nnothing\n\n\n\n\n\n","category":"method"},{"location":"reference/#ParticleHolography.enum_edge","page":"Reference","title":"ParticleHolography.enum_edge","text":"enum_edge(g::MetaGraph)\n\nEnumerates all edges in the given MetaGraph g and returns them as an array of arrays of UUIDs. Each inner array contains the labels of the source and destination nodes of an edge.\n\nArguments\n\ng::MetaGraph: The MetaGraph to enumerate edges from.\n\nReturns\n\nVector{UUID}[]: An array of arrays of UUIDs, where each inner array contains the labels of the source and destination nodes of an edge.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ParticleHolography.finalize_particle_neighborhoods!-Tuple{Any}","page":"Reference","title":"ParticleHolography.finalize_particle_neighborhoods!","text":"finalize_particle_neighborhoods!(particle_neighborhoods)\n\nFinalizes the particle neighborhoods by removing duplicates and particles that are too small or too elongated in the x-y plane. Detailed criteria are as follows:\n\nDuplicate bounding boxes\nBounding boxes with a length-to-width (x-y) ratio greater than 3 or less than 1/3\nBounding boxes with an area less than sqrt10 pixels\nBounding boxes with a depth of 1\n\nArguments\n\nparticle_neighborhoods: The particle neighborhoods to be finalized.\n\nReturns\n\nnothing\n\n\n\n\n\n","category":"method"},{"location":"reference/#ParticleHolography.find_external_contours-Tuple{Any}","page":"Reference","title":"ParticleHolography.find_external_contours","text":"find_external_contours(image)\n\nFinds non-hole contours in binary images. This function is excuted on the CPU. Equivalent to CVRETREXTERNAL and CVCHAINAPPROX_NONE modes of the findContours() function provided in OpenCV.\n\nArguments\n\nimage: The binary image. the image should be a 2D array of 0 and 1.\n\nReturns\n\nVector{Vector{CartesianIndex}}: A vector of contours. Each contour is a vector of CartesianIndex.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ParticleHolography.gen_fulldict-Tuple{Vector{Dict{Base.UUID, Vector{Float32}}}}","page":"Reference","title":"ParticleHolography.gen_fulldict","text":"gen_fulldict(dicts::Vector{Dict{UUID, Vector{Float32}}})\n\nGenerates a dictionary containing the UUIDs of particles for all conceivable frames as keys and their coordinates as values. The input is a vector of dictionaries with UUID keys and values as Vector{Float32}, which includes the coordinates (and diameters) of the particles.\n\nArguments\n\ndicts::Vector{Dict{UUID, Vector{Float32}}}: Vector of dictionaries with UUID keys and values as Vector{Float32}.\n\nReturns\n\nDict{UUID, Vector{Float32}}: Dictionary containing the UUIDs of particles for all conceivable frames as keys and their coordinates as values.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ParticleHolography.gen_fulldict-Tuple{Vector{String}}","page":"Reference","title":"ParticleHolography.gen_fulldict","text":"gen_fulldict(filepaths::Vector{String})\n\nGenerates a dictionary containing the UUIDs of particles for all conceivable frames as keys and their coordinates as values. The input is a vector of file paths containing JSON files with particle coordinates.\n\nArguments\n\nfilepaths::Vector{String}: Vector of file paths containing JSON files with particle coordinates.\n\nReturns\n\nDict{UUID, Vector{Float32}}: Dictionary containing the UUIDs of particles for all conceivable frames as keys and their coordinates as values.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ParticleHolography.getErrorVec","page":"Reference","title":"ParticleHolography.getErrorVec","text":"getErrorVec(vecMap, coefa, gridSize = 128, imgSize = 1024)\n\nReturn the vector `errorVec` obtained by calculating the difference between `targetX` `targetY` and `procX` `procY` obtained by converting `targetX` `targetY` from the `gridx` `gridy` set in the first image to the second image. Also returns `gridx` `gridy` for Jacobian acquisition.\n\nArguments\n\nvecMap: The PIV map.\ncoefa: The coefficients for the quadratic distortion correction.\ngridSize: The size of the grid.\nimgSize: The size of the image.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ParticleHolography.getYacobian","page":"Reference","title":"ParticleHolography.getYacobian","text":"getYacobian(imgSize = 1024, gridSize = 128)\n\nGet the Jacobian matrix for the quadratic distortion correction. The default image size is 1024, and the grid size is 128.\n\nArguments\n\nimgSize::Int: The size of the image.\ngridSize::Int: The size of the grid.\n\nReturns\n\nArray{Float64,2}: The Jacobian matrix.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ParticleHolography.get_distortion_coefficients-Tuple{Matrix{<:AbstractFloat}, Matrix{<:AbstractFloat}}","page":"Reference","title":"ParticleHolography.get_distortion_coefficients","text":"get_distortion_coeficients(img1, img2, gridSize = 128, intrSize = 128, srchSize = 256)\n\nGet the distortion coefficients from the two images img1 and img2. The default grid size is 128, the default search size is 256, and the default image size is 128.\n\nArguments\n\nimg1::Array{<:AbstractFloat,2}: The first image.\nimg2::Array{<:AbstractFloat,2}: The second image.\ngridSize::Int: The size of the grid.\nintrSize::Int: The size of the search.\nsrchSize::Int: The size of the search.\n\nReturns\n\nVector{<:AbstractFloat}: The distortion coefficients.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ParticleHolography.load_gray2float-Tuple{String}","page":"Reference","title":"ParticleHolography.load_gray2float","text":"load_gray2float(path)\n\nLoad a grayscale image from a file and return it as a Array{Float32, 2} array.\n\nArguments\n\npath::String: The path to the image file.\n\nReturns\n\nArray{Float32, 2}: The image as a Float32 array.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ParticleHolography.load_grayimg-Tuple{String}","page":"Reference","title":"ParticleHolography.load_grayimg","text":"load_grayimg(path)\n\nLoad a grayscale image from a file and return it as a Array{Gray{N0f8}, 2} array.\n\nArguments\n\npath::String: The path to the image file.\n\nReturns\n\nArray{Gray{N0f8}, 2}: The image as a Gray{N0f8} array.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ParticleHolography.make_background-Tuple{Vector{String}}","page":"Reference","title":"ParticleHolography.make_background","text":"make_background(pathlist; mode=:mode)\n\nMake a background image from a list of image paths. The background image is calculated by taking the mean or mode of the images in the list. The default mode is :mode.\n\nArguments\n\npathlist::Vector{String}: A list of image paths. glob() can be used to generate this list.\nmode::Symbol: The mode to use for calculating the background. Options are :mean or :mode. Default is :mode.\n\nReturns\n\nArray{Float64, 2}: The background image.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ParticleHolography.modified_Cholesky_decomposition-Tuple{Matrix{<:AbstractFloat}}","page":"Reference","title":"ParticleHolography.modified_Cholesky_decomposition","text":"modified_Cholesky_decomposition(A)\n\nThis function decomposes the target matrix A to A = LDL^T. The diagonal components of the return matrix are the inverse of D, and the lower left components correspond to L. 対象行列Aを A = LDL^T に変換します。戻り値行列の対角成分は D の逆数、左下成分は L に一致します。\n\nArguments\n\nA::Array{<:AbstractFloat,2}: The target matrix.\n\nReturns\n\nArray{AbstractFloat,2}: The decomposed matrix.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ParticleHolography.node_distance","page":"Reference","title":"ParticleHolography.node_distance","text":"node_distance(node1, node2, dim3weight=0.01)\n\nCalculates the Euclidean distance between two nodes in a 3D space.\n\nArguments\n\nnode1: Coordinates of the first node.\nnode2: Coordinates of the second node.\ndim3weight=0.01: Scaling factor for the third dimension. For holographic particle tracking, the third dimension is often less accurate than the first two dimensions, so it is scaled down..\n\n\n\n\n\n","category":"function"},{"location":"reference/#ParticleHolography.particle_bounding_boxes-Tuple{CUDA.CuArray{Bool, 3}}","page":"Reference","title":"ParticleHolography.particle_bounding_boxes","text":"particle_bounding_boxes(d_bin_vol)\n\nDetects the particles in a binary volume and returns the bounding boxes of the particles. This function performs three-dimensional element connected labeling on binary volumes. However, please note that it does not perform strict adjacent connectivity in the optical axis (z) direction. Strict adjacent connectivity in the optical axis direction may result in artifacts not being connected, potentially leading to the detection of many ghost particles. This function assumes that two particles never overlap at exactly the same X-Y coordinates. All elements that overlap in X-Y coordinates are considered connected. Therefore, this method is not suitable for accurate position detection of particles that overlap in X-Y coordinates. Additionally, this processing may have some effects, such as slightly elongating the bounding box of particles in the optical axis direction. However, this has minimal impact on the accuracy of particle position detection.\n\nArguments\n\nd_bin_vol::CuArray{Bool, 3}: The binary volume of reconstructed holographic volume. Binarization can be done by thresholding the reconstructed volume. true values represent the particles and neighboring voxels and vice versa.\n\nReturns\n\nDict{UUID, Vector{Int}}: The bounding boxes of the particles.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ParticleHolography.particle_coor_diams","page":"Reference","title":"ParticleHolography.particle_coor_diams","text":"particle_coor_diams(particle_bbs, d_vol, d_lpf_vol = nothing; depth_metrics = tamura, profile_smoothing_kernel = Kernel.gaussian(5,), diameter_metrics = equivalent_diameter)\n\nCalculates the coordinates and diameters of the particles in the reconstructed volume with the bounding boxe dictionary. The depth of the particles is the maximum of the profile that is calculated using the depth_metrics function at each slice of the bounding box. The profile is then smoothed using the profile_smoothing_kernel. The x and y coordinates are calculated by finding the center of mass of the slice with the detected depth. The low pass filtered volume would be better for coordinate detection. The diameter of the particles is calculated using the diameter_metrics function. If the low pass filtered volume is provided, the coordinate is calculated using the low pass filtered volume.\n\nArguments\n\nparticle_bbs::Dict{UUID, Vector{Int}}: The bounding boxes of the particles.\nd_vol::CuArray{N0f8, 3}: The reconstructed volume.\n\nOptional arguments\n\nd_lpf_vol::Union{CuArray{N0f8,3}, Nothing} = nothing: The low pass filtered volume.\n\nOptional keyword arguments\n\ndepth_metrics::Function = tamura: The function that calculates the depth profile of the particles.\nprofile_smoothing_kernel = Kernel.gaussian((5,)): The kernel used for smoothing the depth profile.\ndiameter_metrics::Function = equivalent_diameter: The function that calculates the diameter of the particles.\n\nReturns\n\nDict{UUID, Vector{Float32}}: The coordinates and diameters of the particles.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ParticleHolography.particle_coordinates-Tuple{Dict{Base.UUID, Vector{Int64}}, CUDA.CuArray{FixedPointNumbers.N0f8, 3}}","page":"Reference","title":"ParticleHolography.particle_coordinates","text":"particle_coordinates(particle_bbs, d_vol; depth_metrics = tamura, profile_smoothing_kernel = Kernel.gaussian(5,))\n\nCalculates the coordinates of the particles in the reconstructed volume with the bounding boxe dictionary. The depth of the particles is the maximum of the profile that is calculated using the depth_metrics function at each slice of the bounding box. The profile is then smoothed using the profile_smoothing_kernel. The x and y coordinates are calculated by finding the center of mass of the slice with the detected depth. The low pass filtered volume would be better for coordinate detection.\n\nArguments\n\nparticle_bbs::Dict{UUID, Vector{Int}}: The bounding boxes of the particles.\nd_vol::CuArray{N0f8, 3}: The reconstructed volume.\ndepth_metrics::Function = tamura: The function that calculates the depth profile of the particles.\nprofile_smoothing_kernel = Kernel.gaussian((5,)): The kernel used for smoothing the depth profile.\n\nReturns\n\nDict{UUID, Vector{Float32}}: The coordinates of the particles.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ParticleHolography.particleplot!-Tuple","page":"Reference","title":"ParticleHolography.particleplot!","text":"particleplot(data::Dict{UUID, Vector{Float32}}; scaling=(1.0, 1.0, -1.0), shift=(0.0, 0.0, 0.0), kwargs...)\nparticleplot!(data::Dict{UUID, Vector{Float32}}; scaling=(1.0, 1.0, -1.0), shift=(0.0, 0.0, 0.0), kwargs...)\n\nPlots the particles in the 3D space. The data should be a dictionary with UUID keys and values as Vector{Float32}, which includes the coordinates of the particles. The scaling and shift parameters are used to transform the coordinates to the observed space.\n\nIn this plot, we display the x-y plane in the foreground by mapping the data's z-axis to the y-axis of Plots.scatter(). To align the data's y-axis with the hologram image coordinates, we set zflip = true by default. This results in a left-handed coordinate system, so we additionally set yflip = true to correct for this. The z-coordinate of the data (slice number) is opposite to the optical axis direction shown in the Introduction, so we set the z-axis data scaling to -1.0 for correct display.\n\nArguments\n\ndata::Dict{UUID, Vector{Float32}}: The coordinates of the particles.\n\nOptional keyword arguments\n\nscaling::Tuple{Float32, Float32, Float32} = (1.0, 1.0, -1.0): The scaling of the coordinates.\nshift::Tuple{Float32, Float32, Float32} = (0.0, 0.0, 0.0): The shift of the coordinates.\nkwargs...: Additional keyword arguments passed to Plots.scatter().\n\n\n\n\n\n","category":"method"},{"location":"reference/#ParticleHolography.particleplot!-Tuple{RecipesBase.AbstractPlot, Vararg{Any}}","page":"Reference","title":"ParticleHolography.particleplot!","text":"particleplot(data::Dict{UUID, Vector{Float32}}; scaling=(1.0, 1.0, -1.0), shift=(0.0, 0.0, 0.0), kwargs...)\nparticleplot!(data::Dict{UUID, Vector{Float32}}; scaling=(1.0, 1.0, -1.0), shift=(0.0, 0.0, 0.0), kwargs...)\n\nPlots the particles in the 3D space. The data should be a dictionary with UUID keys and values as Vector{Float32}, which includes the coordinates of the particles. The scaling and shift parameters are used to transform the coordinates to the observed space.\n\nIn this plot, we display the x-y plane in the foreground by mapping the data's z-axis to the y-axis of Plots.scatter(). To align the data's y-axis with the hologram image coordinates, we set zflip = true by default. This results in a left-handed coordinate system, so we additionally set yflip = true to correct for this. The z-coordinate of the data (slice number) is opposite to the optical axis direction shown in the Introduction, so we set the z-axis data scaling to -1.0 for correct display.\n\nArguments\n\ndata::Dict{UUID, Vector{Float32}}: The coordinates of the particles.\n\nOptional keyword arguments\n\nscaling::Tuple{Float32, Float32, Float32} = (1.0, 1.0, -1.0): The scaling of the coordinates.\nshift::Tuple{Float32, Float32, Float32} = (0.0, 0.0, 0.0): The shift of the coordinates.\nkwargs...: Additional keyword arguments passed to Plots.scatter().\n\n\n\n\n\n","category":"method"},{"location":"reference/#ParticleHolography.particleplot-Tuple","page":"Reference","title":"ParticleHolography.particleplot","text":"particleplot(data::Dict{UUID, Vector{Float32}}; scaling=(1.0, 1.0, -1.0), shift=(0.0, 0.0, 0.0), kwargs...)\nparticleplot!(data::Dict{UUID, Vector{Float32}}; scaling=(1.0, 1.0, -1.0), shift=(0.0, 0.0, 0.0), kwargs...)\n\nPlots the particles in the 3D space. The data should be a dictionary with UUID keys and values as Vector{Float32}, which includes the coordinates of the particles. The scaling and shift parameters are used to transform the coordinates to the observed space.\n\nIn this plot, we display the x-y plane in the foreground by mapping the data's z-axis to the y-axis of Plots.scatter(). To align the data's y-axis with the hologram image coordinates, we set zflip = true by default. This results in a left-handed coordinate system, so we additionally set yflip = true to correct for this. The z-coordinate of the data (slice number) is opposite to the optical axis direction shown in the Introduction, so we set the z-axis data scaling to -1.0 for correct display.\n\nArguments\n\ndata::Dict{UUID, Vector{Float32}}: The coordinates of the particles.\n\nOptional keyword arguments\n\nscaling::Tuple{Float32, Float32, Float32} = (1.0, 1.0, -1.0): The scaling of the coordinates.\nshift::Tuple{Float32, Float32, Float32} = (0.0, 0.0, 0.0): The shift of the coordinates.\nkwargs...: Additional keyword arguments passed to Plots.scatter().\n\n\n\n\n\n","category":"method"},{"location":"reference/#ParticleHolography.quadratic_distortion_correction-Tuple{Matrix{<:AbstractFloat}, Vector{<:AbstractFloat}}","page":"Reference","title":"ParticleHolography.quadratic_distortion_correction","text":"quadratic_distortion_correction(img, coefa)\n\nCorrect the quadratic distortion in the grayscale image img using the coefficients coefa. img have to be square, and coefa have to be a vector of 12 coefficients.\n\nArguments\n\nimg::Array{<:AbstractFloat,2}: The image to correct.\ncoefa::Vector{<:AbstractFloat}: The coefficients to correct the distortion.\n\nReturns\n\nArray{AbstractFloat,2}: The corrected image.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ParticleHolography.simultanious_equation_solver-Tuple{Matrix{<:AbstractFloat}, Matrix{<:AbstractFloat}, Vector{<:AbstractFloat}}","page":"Reference","title":"ParticleHolography.simultanious_equation_solver","text":"simultanious_equation_solver(chlskyMat,yacob,errorArray)\n\nSolve the equation chlskyMat x = - yacob errorArray using the Cholesky decomposition matrix chlskyMat, Jacobian yacob, and error vector errorArray.\n\nArguments\n\nchlskyMat::Array{<:AbstractFloat,2}: The Cholesky decomposition matrix.\nyacob::Array{<:AbstractFloat,2}: The Jacobian matrix.\nerrorArray::Array{<:AbstractFloat,1}: The error vector.\n\nReturns\n\nArray{AbstractFloat,1}: The solution vector.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ParticleHolography.tamura-Tuple{AbstractMatrix{<:AbstractFloat}}","page":"Reference","title":"ParticleHolography.tamura","text":"tamura(arr)\n\nCalculates the Tamura coefficient of an array. The Tamura coefficient is defined as the standard deviation divided by the mean of the array. Please refer to the use in digital holography https://doi.org/10.1364/OL.36.001945\n\nArguments\n\narr::Array{Float32, 2}: The array for which the Tamura coefficient is calculated.\n\nReturns\n\nFloat32: The Tamura coefficient of the array.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ParticleHolography.trajectoryplot!-Tuple","page":"Reference","title":"ParticleHolography.trajectoryplot!","text":"trajectoryplot(paths::Vector{Vector{UUID}}, fulldict::Dict{UUID, Vector{Float32}}; colors=palette(:tab10), framerange=(0, 1024), scaling=(1.0, 1.0, -1.0), shift=(0.0, 0.0, 0.0), kwargs...)\ntrajectoryplot!(paths::Vector{Vector{UUID}}, fulldict::Dict{UUID, Vector{Float32}}; colors=palette(:tab10), framerange=(0, 1024), scaling=(1.0, 1.0, -1.0), shift=(0.0, 0.0, 0.0), kwargs...)\n\nPlots particle trajectories with different colors in 3D space. paths is a Vector{Vector{UUID}}, where each element represents the trajectory of particles considered identical. fulldict is a dictionary containing the UUIDs of particles for all conceivable frames as keys and their coordinates as values, generated using gen_fulldict. colors specifies the palette for trajectory colors, defaulting to palette(:tab10). For scaling and shift, refer to particleplot. framerange specifies the range of frames to plot. For example, when generating fulldict for N consecutive frames, setting framerange=(N-10+1, N) will plot only the trajectories of the last 10 frames. When creating animations with the @anim macro, setting framerange from (1,1) to (1,N) will create an N-frame animation.\n\nArguments\n\npaths::Vector{Vector{UUID}}: The trajectories of the particles.\nfulldict::Dict{UUID, Vector{Float32}}: The dictionary of all particles.\n\nOptional keyword arguments\n\ncolors::Vector{Colorant} = palette(:tab10): The colors of the trajectories.\nframerange::Tuple{Int, Int} = (0, 1024): The range of frames to plot.\nscaling::Tuple{Float32, Float32, Float32} = (1.0, 1.0, -1.0): The scaling of the coordinates.\nshift::Tuple{Float32, Float32, Float32} = (0.0, 0.0, 0.0): The shift of the coordinates.\nkwargs...: Additional keyword arguments passed to Plots.@series.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ParticleHolography.trajectoryplot!-Tuple{RecipesBase.AbstractPlot, Vararg{Any}}","page":"Reference","title":"ParticleHolography.trajectoryplot!","text":"trajectoryplot(paths::Vector{Vector{UUID}}, fulldict::Dict{UUID, Vector{Float32}}; colors=palette(:tab10), framerange=(0, 1024), scaling=(1.0, 1.0, -1.0), shift=(0.0, 0.0, 0.0), kwargs...)\ntrajectoryplot!(paths::Vector{Vector{UUID}}, fulldict::Dict{UUID, Vector{Float32}}; colors=palette(:tab10), framerange=(0, 1024), scaling=(1.0, 1.0, -1.0), shift=(0.0, 0.0, 0.0), kwargs...)\n\nPlots particle trajectories with different colors in 3D space. paths is a Vector{Vector{UUID}}, where each element represents the trajectory of particles considered identical. fulldict is a dictionary containing the UUIDs of particles for all conceivable frames as keys and their coordinates as values, generated using gen_fulldict. colors specifies the palette for trajectory colors, defaulting to palette(:tab10). For scaling and shift, refer to particleplot. framerange specifies the range of frames to plot. For example, when generating fulldict for N consecutive frames, setting framerange=(N-10+1, N) will plot only the trajectories of the last 10 frames. When creating animations with the @anim macro, setting framerange from (1,1) to (1,N) will create an N-frame animation.\n\nArguments\n\npaths::Vector{Vector{UUID}}: The trajectories of the particles.\nfulldict::Dict{UUID, Vector{Float32}}: The dictionary of all particles.\n\nOptional keyword arguments\n\ncolors::Vector{Colorant} = palette(:tab10): The colors of the trajectories.\nframerange::Tuple{Int, Int} = (0, 1024): The range of frames to plot.\nscaling::Tuple{Float32, Float32, Float32} = (1.0, 1.0, -1.0): The scaling of the coordinates.\nshift::Tuple{Float32, Float32, Float32} = (0.0, 0.0, 0.0): The shift of the coordinates.\nkwargs...: Additional keyword arguments passed to Plots.@series.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ParticleHolography.trajectoryplot-Tuple","page":"Reference","title":"ParticleHolography.trajectoryplot","text":"trajectoryplot(paths::Vector{Vector{UUID}}, fulldict::Dict{UUID, Vector{Float32}}; colors=palette(:tab10), framerange=(0, 1024), scaling=(1.0, 1.0, -1.0), shift=(0.0, 0.0, 0.0), kwargs...)\ntrajectoryplot!(paths::Vector{Vector{UUID}}, fulldict::Dict{UUID, Vector{Float32}}; colors=palette(:tab10), framerange=(0, 1024), scaling=(1.0, 1.0, -1.0), shift=(0.0, 0.0, 0.0), kwargs...)\n\nPlots particle trajectories with different colors in 3D space. paths is a Vector{Vector{UUID}}, where each element represents the trajectory of particles considered identical. fulldict is a dictionary containing the UUIDs of particles for all conceivable frames as keys and their coordinates as values, generated using gen_fulldict. colors specifies the palette for trajectory colors, defaulting to palette(:tab10). For scaling and shift, refer to particleplot. framerange specifies the range of frames to plot. For example, when generating fulldict for N consecutive frames, setting framerange=(N-10+1, N) will plot only the trajectories of the last 10 frames. When creating animations with the @anim macro, setting framerange from (1,1) to (1,N) will create an N-frame animation.\n\nArguments\n\npaths::Vector{Vector{UUID}}: The trajectories of the particles.\nfulldict::Dict{UUID, Vector{Float32}}: The dictionary of all particles.\n\nOptional keyword arguments\n\ncolors::Vector{Colorant} = palette(:tab10): The colors of the trajectories.\nframerange::Tuple{Int, Int} = (0, 1024): The range of frames to plot.\nscaling::Tuple{Float32, Float32, Float32} = (1.0, 1.0, -1.0): The scaling of the coordinates.\nshift::Tuple{Float32, Float32, Float32} = (0.0, 0.0, 0.0): The shift of the coordinates.\nkwargs...: Additional keyword arguments passed to Plots.@series.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ParticleHolography.update_particle_neighborhoods!-Tuple{Any, Any, Any}","page":"Reference","title":"ParticleHolography.update_particle_neighborhoods!","text":"update_particle_neighborhoods!(particle_neighborhoods, bounding_rectangles, slicenum)\n\nUpdates the particle neighborhoods with new bounding rectangles from a new slice. If a bounding rectangle overlaps with an existing particle neighborhood in the x-y plane, the neighborhood is updated to include the new rectangle and the z-range is adjusted accordingly. If there is no overlap, a new particle neighborhood is created. CAUTION: This function does NOT support multiple particles along the z-axis, and it is recommended to use update_particle_neighborhoods3d! instead. If there are multiple particles along the z-axis, they may be merged into one particle neighborhood.\n\nArguments\n\nparticle_neighborhoods: The current particle neighborhoods.\nbounding_rectangles: The new bounding rectangles to be added.\nslicenum: The slice number of the new bounding rectangles.\n\nReturns\n\nnothing\n\n\n\n\n\n","category":"method"},{"location":"reference/#ParticleHolography.update_particle_neighborhoods3d!-Tuple{Any, Any, Any}","page":"Reference","title":"ParticleHolography.update_particle_neighborhoods3d!","text":"update_particle_neighborhoods3d!(particle_neighborhoods, bounding_rectangles, slicenum)\n\nUpdates the particle neighborhoods with new bounding rectangles from a new slice. If a bounding rectangle overlaps with an existing particle neighborhood in the x-y plane, the neighborhood is updated to include the new rectangle and the z-range is adjusted accordingly. If there is no overlap, a new particle neighborhood is created. This function supports multiple particles along the z-axis.\n\nArguments\n\nparticle_neighborhoods: The current particle neighborhoods.\nbounding_rectangles: The new bounding rectangles to be added.\nslicenum: The slice number of the new bounding rectangles.\n\nReturns\n\nnothing\n\n\n\n\n\n","category":"method"},{"location":"#ParticleHolography","page":"Home","title":"ParticleHolography","text":"Documentation for ParticleHolography.\n\nA package for particle measurement using inline holography.","category":"section"},{"location":"#What-you-can-do-with-ParticleHolography.jl","page":"Home","title":"What you can do with ParticleHolography.jl","text":"Volume reconstruction from inline holograms using NVIDIA GPUs (CUDA.jl)\nDetect particles in the reconstructed volume (image stack)\nVisualize the particle trajectories\n\n<div style=\"display:flex; align-items:flex-start;\">\n   <div style=\"flex:1; margin-right:10px;\">\n       <img src=\"assets/outhologif.gif\" alt=\"4000 fps droplet holograms\" style=\"max-width:100%; height:auto;\">\n       <p style=\"text-align:center;\">Droplet holograms @4000 fps</p>\n   </div>\n   <div style=\"flex:1.23;\">\n       <img src=\"assets/sub_animated_3d.gif\" alt=\"Particle trajectories\" style=\"max-width:100%; height:auto;\">\n       <p style=\"text-align:center;\">Particle trajectories</p>\n   </div>\n</div>","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(\"ParticleHolography\")","category":"section"},{"location":"#Demo","page":"Home","title":"Demo","text":"For a quick demo, please see the ParticleHolography.jl demo notebook","category":"section"},{"location":"usage/preprocessings/#preprocessings","page":"Preprocessings","title":"Preprocessings","text":"","category":"section"},{"location":"usage/preprocessings/#Read-images","page":"Preprocessings","title":"Read images","text":"Use the load_gray2float function to read grayscale hologram images.","category":"section"},{"location":"usage/preprocessings/#Background-removal","page":"Preprocessings","title":"Background removal","text":"Given a list of hologram paths, a background image is generated by the mean or mode of the brightness values at each pixel of the hologram. Lists of holograms can be obtained using the Glob package. It is preferable if these are time series data that record few objects. It may takes a while to process a large number of holograms. A progress bar is displayed during processing.\n\nusing ParticleHolography\nusing Glob\n\npathlist = glob(\"path/to/hologram/*.png\")\nbkg = make_background(pathlist, mode=:mode)\n\n# Remove the background\nimg = load_gray2float(\"path/to/hologram/holo1.png\")\nimg .= img .- bkg .+ 64/255\n\nThe mode argument can be set to :mean or :mode. The default is :mode. ","category":"section"},{"location":"usage/preprocessings/#ParticleHolography.load_gray2float","page":"Preprocessings","title":"ParticleHolography.load_gray2float","text":"load_gray2float(path)\n\nLoad a grayscale image from a file and return it as a Array{Float32, 2} array.\n\nArguments\n\npath::String: The path to the image file.\n\nReturns\n\nArray{Float32, 2}: The image as a Float32 array.\n\n\n\n\n\n","category":"function"},{"location":"usage/preprocessings/#ParticleHolography.make_background","page":"Preprocessings","title":"ParticleHolography.make_background","text":"make_background(pathlist; mode=:mode)\n\nMake a background image from a list of image paths. The background image is calculated by taking the mean or mode of the images in the list. The default mode is :mode.\n\nArguments\n\npathlist::Vector{String}: A list of image paths. glob() can be used to generate this list.\nmode::Symbol: The mode to use for calculating the background. Options are :mean or :mode. Default is :mode.\n\nReturns\n\nArray{Float64, 2}: The background image.\n\n\n\n\n\n","category":"function"},{"location":"usage/animplot/#Animated-plots","page":"Animated plots","title":"Animated plots","text":"In Particle handling, we explained how to plot particles and their trajectories. However, when dealing with time series data, it can be useful to save the temporal evolution as a GIF animation. Below, we provide several examples of how to do this.","category":"section"},{"location":"usage/animplot/#Animated-ParticlePlot","page":"Animated plots","title":"Animated ParticlePlot","text":"using ParticleHolography\nusing Plots\nusing Glob\n\nfiles = glob(\"savejson_lpf4_priter6_th24/*.json\")[1:50]\n\ncolors = cgrad(:viridis)[LinRange(0, 1, length(files))]\n\nplot()\nanim = @animate for (idx, file) in enumerate(files)\n    data = dictload(file)\n    particleplot!(data, legend = false, scaling=(10.0, 10.0, -100.0), shift=(0.0, 0.0, 1e5), color=colors[idx], xlabel=\"x [µm]\", ylabel=\"z [µm]\", zlabel=\"y [µm]\", xlim=(0,10240), ylim=(0,1e5), zlim=(0,10240), dpi=300)\nend\n\ngif(anim, \"particles.gif\", fps = 10)\n\n(Image: Animated detected particles)","category":"section"},{"location":"usage/animplot/#Animated-TrajectoryPlot","page":"Animated plots","title":"Animated TrajectoryPlot","text":"note: Note\nCreating animations using TrajectoryPlot may take a very long time. This issue will be addressed in future updates.\n\nusing ParticleHolography\nusing Plots\nusing Glob\n\nfiles = glob(\"savejson_lpf4_priter6_th24/*.json\")[1:50]\n\ndicts = ParticleHolography.dictload.(files)\n\ngraphs = [Labonte(dict1, dict2) for (dict1, dict2) in zip(dicts[1:end-1], dicts[2:end])]\n\npaths = ParticleHolography.enum_edge(graphs[1])\n\nfor graph in graphs[2:end]\n    append_path!(paths, graph)\nend\n\nfulldict = gen_fulldict(files)\n\nplot()\nanim = @animate for idx in 1:50\n    trajectoryplot!(paths, fulldict, framerange = (1, idx),legend = false, scaling=(10.0, 10.0, -100.0), shift=(0.0, 0.0, 1e5), xlabel=\"x [µm]\", ylabel=\"z [µm]\", zlabel=\"y [µm]\", xlim=(0,10240), ylim=(0,1e5), zlim=(0,10240), dpi=300)\nend\n\ngif(anim, \"trajectories.gif\", fps = 10)\n\n(Image: Animated trajectories)","category":"section"}]
}
