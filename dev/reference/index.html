<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · ParticleHolography.jl</title><meta name="title" content="Reference · ParticleHolography.jl"/><meta property="og:title" content="Reference · ParticleHolography.jl"/><meta property="twitter:title" content="Reference · ParticleHolography.jl"/><meta name="description" content="Documentation for ParticleHolography.jl."/><meta property="og:description" content="Documentation for ParticleHolography.jl."/><meta property="twitter:description" content="Documentation for ParticleHolography.jl."/><meta property="og:url" content="https://dainakai.github.io/ParticleHolography.jl/reference/"/><meta property="twitter:url" content="https://dainakai.github.io/ParticleHolography.jl/reference/"/><link rel="canonical" href="https://dainakai.github.io/ParticleHolography.jl/reference/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/styles.css" rel="stylesheet" type="text/css"/><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="ParticleHolography.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">ParticleHolography.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../whats_inline_holography/">What&#39;s inline holography?</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/gabor/">Gabor holography</a></li><li><a class="tocitem" href="../tutorials/pr/">Phase retrieval holography</a></li><li><a class="tocitem" href="../tutorials/particle/">Particle handling</a></li></ul></li><li><span class="tocitem">Usage</span><ul><li><a class="tocitem" href="../usage/preprocessings/">Preprocessings</a></li><li><a class="tocitem" href="../usage/reconstruction/">Volume reconstruction</a></li><li><a class="tocitem" href="../usage/lowpassfilter/">Low-pass filtering</a></li><li><a class="tocitem" href="../usage/animplot/">Animated plots</a></li></ul></li><li class="is-active"><a class="tocitem" href>Reference</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Types-and-Functions"><span>Types and Functions</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/dainakai/ParticleHolography.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/dainakai/ParticleHolography.jl/blob/main/docs/src/reference.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><p>This is the reference documentation for the <code>ParticleHolography</code> package.</p><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#ParticleHolography.CuLowPassFilter"><code>ParticleHolography.CuLowPassFilter</code></a></li><li><a href="#ParticleHolography.CuTransfer"><code>ParticleHolography.CuTransfer</code></a></li><li><a href="#ParticleHolography.CuTransferSqrtPart"><code>ParticleHolography.CuTransferSqrtPart</code></a></li><li><a href="#ParticleHolography.CuWavefront"><code>ParticleHolography.CuWavefront</code></a></li><li><a href="#ParticleHolography.Labonte-Tuple{Any, Any}"><code>ParticleHolography.Labonte</code></a></li><li><a href="#ParticleHolography.append_path!-Tuple{Any, MetaGraphsNext.MetaGraph}"><code>ParticleHolography.append_path!</code></a></li><li><a href="#ParticleHolography.cu_apply_low_pass_filter-Tuple{CuWavefront, CuLowPassFilter}"><code>ParticleHolography.cu_apply_low_pass_filter</code></a></li><li><a href="#ParticleHolography.cu_apply_low_pass_filter!-Tuple{CuWavefront, CuLowPassFilter}"><code>ParticleHolography.cu_apply_low_pass_filter!</code></a></li><li><a href="#ParticleHolography.cu_connected_component_labeling-Tuple{Any}"><code>ParticleHolography.cu_connected_component_labeling</code></a></li><li><a href="#ParticleHolography.cu_gabor_wavefront-Tuple{CUDA.CuArray{Float32, 2}}"><code>ParticleHolography.cu_gabor_wavefront</code></a></li><li><a href="#ParticleHolography.cu_get_reconst_complex_vol-Tuple{CuWavefront{ComplexF32}, CuTransfer{ComplexF32}, CuTransfer{ComplexF32}, Int64}"><code>ParticleHolography.cu_get_reconst_complex_vol</code></a></li><li><a href="#ParticleHolography.cu_get_reconst_vol"><code>ParticleHolography.cu_get_reconst_vol</code></a></li><li><a href="#ParticleHolography.cu_get_reconst_vol_and_xyprojection"><code>ParticleHolography.cu_get_reconst_vol_and_xyprojection</code></a></li><li><a href="#ParticleHolography.cu_get_reconst_xyprojection-Tuple{CuWavefront{ComplexF32}, CuTransfer{ComplexF32}, CuTransfer{ComplexF32}, Int64}"><code>ParticleHolography.cu_get_reconst_xyprojection</code></a></li><li><a href="#ParticleHolography.cu_phase_retrieval_holo-Tuple{CUDA.CuArray{Float32, 2}, CUDA.CuArray{Float32, 2}, CuTransfer{ComplexF32}, CuTransfer{ComplexF32}, Int64, Int64}"><code>ParticleHolography.cu_phase_retrieval_holo</code></a></li><li><a href="#ParticleHolography.cu_rectangle_filter-Tuple{AbstractFloat, AbstractFloat, Int64, AbstractFloat}"><code>ParticleHolography.cu_rectangle_filter</code></a></li><li><a href="#ParticleHolography.cu_super_gaussian_filter-Tuple{AbstractFloat, AbstractFloat, Int64, AbstractFloat}"><code>ParticleHolography.cu_super_gaussian_filter</code></a></li><li><a href="#ParticleHolography.cu_transfer-Tuple{AbstractFloat, Int64, AbstractFloat, CuTransferSqrtPart{Float32}}"><code>ParticleHolography.cu_transfer</code></a></li><li><a href="#ParticleHolography.cu_transfer_sqrt_arr-Tuple{Int64, AbstractFloat, AbstractFloat}"><code>ParticleHolography.cu_transfer_sqrt_arr</code></a></li><li><a href="#ParticleHolography.dictload-Tuple{Any}"><code>ParticleHolography.dictload</code></a></li><li><a href="#ParticleHolography.dictsave-Tuple{Any, Dict}"><code>ParticleHolography.dictsave</code></a></li><li><a href="#ParticleHolography.enum_edge"><code>ParticleHolography.enum_edge</code></a></li><li><a href="#ParticleHolography.finalize_particle_neighborhoods!-Tuple{Any}"><code>ParticleHolography.finalize_particle_neighborhoods!</code></a></li><li><a href="#ParticleHolography.find_external_contours-Tuple{Any}"><code>ParticleHolography.find_external_contours</code></a></li><li><a href="#ParticleHolography.gen_fulldict-Tuple{Vector{Dict{Base.UUID, Vector{Float32}}}}"><code>ParticleHolography.gen_fulldict</code></a></li><li><a href="#ParticleHolography.gen_fulldict-Tuple{Vector{String}}"><code>ParticleHolography.gen_fulldict</code></a></li><li><a href="#ParticleHolography.getErrorVec"><code>ParticleHolography.getErrorVec</code></a></li><li><a href="#ParticleHolography.getYacobian"><code>ParticleHolography.getYacobian</code></a></li><li><a href="#ParticleHolography.get_distortion_coefficients-Tuple{Matrix{&lt;:AbstractFloat}, Matrix{&lt;:AbstractFloat}}"><code>ParticleHolography.get_distortion_coefficients</code></a></li><li><a href="#ParticleHolography.load_gray2float-Tuple{String}"><code>ParticleHolography.load_gray2float</code></a></li><li><a href="#ParticleHolography.make_background-Tuple{Vector{String}}"><code>ParticleHolography.make_background</code></a></li><li><a href="#ParticleHolography.modified_Cholesky_decomposition-Tuple{Matrix{&lt;:AbstractFloat}}"><code>ParticleHolography.modified_Cholesky_decomposition</code></a></li><li><a href="#ParticleHolography.node_distance"><code>ParticleHolography.node_distance</code></a></li><li><a href="#ParticleHolography.particle_bounding_boxes-Tuple{CUDA.CuArray{Bool, 3}}"><code>ParticleHolography.particle_bounding_boxes</code></a></li><li><a href="#ParticleHolography.particle_coor_diams"><code>ParticleHolography.particle_coor_diams</code></a></li><li><a href="#ParticleHolography.particle_coordinates-Tuple{Dict{Base.UUID, Vector{Int64}}, CUDA.CuArray{FixedPointNumbers.N0f8, 3}}"><code>ParticleHolography.particle_coordinates</code></a></li><li><a href="#ParticleHolography.particleplot-Tuple"><code>ParticleHolography.particleplot</code></a></li><li><a href="#ParticleHolography.particleplot!-Tuple"><code>ParticleHolography.particleplot!</code></a></li><li><a href="#ParticleHolography.particleplot!-Tuple{RecipesBase.AbstractPlot, Vararg{Any}}"><code>ParticleHolography.particleplot!</code></a></li><li><a href="#ParticleHolography.quadratic_distortion_correction-Tuple{Matrix{&lt;:AbstractFloat}, Vector{&lt;:AbstractFloat}}"><code>ParticleHolography.quadratic_distortion_correction</code></a></li><li><a href="#ParticleHolography.simultanious_equation_solver-Tuple{Matrix{&lt;:AbstractFloat}, Matrix{&lt;:AbstractFloat}, Vector{&lt;:AbstractFloat}}"><code>ParticleHolography.simultanious_equation_solver</code></a></li><li><a href="#ParticleHolography.tamura-Tuple{AbstractMatrix{&lt;:AbstractFloat}}"><code>ParticleHolography.tamura</code></a></li><li><a href="#ParticleHolography.trajectoryplot-Tuple"><code>ParticleHolography.trajectoryplot</code></a></li><li><a href="#ParticleHolography.trajectoryplot!-Tuple{RecipesBase.AbstractPlot, Vararg{Any}}"><code>ParticleHolography.trajectoryplot!</code></a></li><li><a href="#ParticleHolography.trajectoryplot!-Tuple"><code>ParticleHolography.trajectoryplot!</code></a></li></ul><h2 id="Types-and-Functions"><a class="docs-heading-anchor" href="#Types-and-Functions">Types and Functions</a><a id="Types-and-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Types-and-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ParticleHolography.CuLowPassFilter" href="#ParticleHolography.CuLowPassFilter"><code>ParticleHolography.CuLowPassFilter</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CuLowPassFilter{T&lt;: AbstractFloat}</code></pre><p>A struct that holds the data for the low pass filter. This can be multiplied with the Fourier transform of wavefront to get the low pass filtered wavefront after propagation.</p><p><strong>Fields</strong></p><ul><li><code>data::CuArray{T,2}</code>: The data for the low pass filter.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dainakai/ParticleHolography.jl/blob/daf5c5b0b2f5ab0da18923971d43f8be504941eb/src/types.jl#L42-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ParticleHolography.CuTransfer" href="#ParticleHolography.CuTransfer"><code>ParticleHolography.CuTransfer</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CuTransfer{T&lt;: Complex}</code></pre><p>A struct that holds the data for the transfer function.</p><p><strong>Fields</strong></p><ul><li><code>data::CuArray{T,2}</code>: The data for the transfer function.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dainakai/ParticleHolography.jl/blob/daf5c5b0b2f5ab0da18923971d43f8be504941eb/src/types.jl#L17-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ParticleHolography.CuTransferSqrtPart" href="#ParticleHolography.CuTransferSqrtPart"><code>ParticleHolography.CuTransferSqrtPart</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CuTransferSqrtPart{T&lt;: AbstractFloat}</code></pre><p>A struct that holds the data for the square root part of the transfer function.</p><p><strong>Fields</strong></p><ul><li><code>data::CuArray{T,2}</code>: The data for the square root part of the transfer function.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dainakai/ParticleHolography.jl/blob/daf5c5b0b2f5ab0da18923971d43f8be504941eb/src/types.jl#L5-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ParticleHolography.CuWavefront" href="#ParticleHolography.CuWavefront"><code>ParticleHolography.CuWavefront</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CuWavefront{T&lt;: Complex}</code></pre><p>A struct that holds the data for the wavefront.</p><p><strong>Fields</strong></p><ul><li><code>data::CuArray{T,2}</code>: The data for the wavefront.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dainakai/ParticleHolography.jl/blob/daf5c5b0b2f5ab0da18923971d43f8be504941eb/src/types.jl#L29-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ParticleHolography.Labonte-Tuple{Any, Any}" href="#ParticleHolography.Labonte-Tuple{Any, Any}"><code>ParticleHolography.Labonte</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Labonte(dict1, dict2; Dmax=50.0, α=0.005, R=50.0, Rend=0.1, β=0.9, N=10)</code></pre><p>Implementation of the improved Labonté algorithm [<a href="../tutorials/particle/#ohmi">14</a>, <a href="../tutorials/particle/#labonte">15</a>]. Takes dictionaries of detected particle coordinates at two time points as input and returns a graph representing the correspondence between particles at these two time points. The graph contains UUID keys of all particles from both time points as nodes, with directed edges representing particle correspondences from particles in <code>dict1</code> to particles in <code>dict2</code>. All correspondences can be retrieved using the <a href="#ParticleHolography.enum_edge"><code>enum_edge</code></a> function.</p><p><strong>Arguments</strong></p><ul><li><code>dict1::Dict{UUID, Vector{Float32}}</code>: Dictionary of detected particle coordinates at the first time point.</li><li><code>dict2::Dict{UUID, Vector{Float32}}</code>: Dictionary of detected particle coordinates at the second time point.</li></ul><p><strong>Optional keyword arguments</strong></p><ul><li><code>Dmax::Float32=50.0</code>: Maximum allowable movement distance.</li><li><code>α::Float32=0.005</code>: Learning rate.</li><li><code>R::Float32=50.0</code>: Initial value of the inspection neighborhood radius.</li><li><code>Rend::Float32=0.1</code>: Final value of the inspection neighborhood radius. The algorithm terminates when the inspection radius becomes smaller than this value through iterations.</li><li><code>β::Float32=0.9</code>: Decay rate of the inspection neighborhood radius.</li><li><code>N::Int=10</code>: Nodes that are not selected as winners for N consecutive times are removed. Refer to the original paper for details.</li></ul><p><strong>Returns</strong></p><ul><li><code>MetaGraph</code>: Graph representing the correspondence between detected particles at two time points.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dainakai/ParticleHolography.jl/blob/daf5c5b0b2f5ab0da18923971d43f8be504941eb/src/particle_tracking.jl#L185-L204">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ParticleHolography.append_path!-Tuple{Any, MetaGraphsNext.MetaGraph}" href="#ParticleHolography.append_path!-Tuple{Any, MetaGraphsNext.MetaGraph}"><code>ParticleHolography.append_path!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">append_path!(paths, g::MetaGraph)</code></pre><p>Adds correspondences from the MetaGraph <code>g</code> to the trajectory array <code>paths</code> initialized by the <a href="#ParticleHolography.enum_edge"><code>enum_edge</code></a> function. Specifically, if the last element of a <code>Vector{UUID}</code> array <code>path</code> in <code>paths</code> matches the starting point of an edge in <code>g</code>, the endpoint of that edge is appended to <code>paths</code>. If the graph is not injective, <code>path</code> is duplicated.</p><p><strong>Arguments</strong></p><ul><li><code>paths::Vector{UUID}[]</code>: Array of trajectories.</li><li><code>g::MetaGraph</code>: The <code>MetaGraph</code> from which correspondences are to be added.</li></ul><p><strong>Returns</strong></p><ul><li><code>nothing</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dainakai/ParticleHolography.jl/blob/daf5c5b0b2f5ab0da18923971d43f8be504941eb/src/particle_tracking.jl#L239-L250">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ParticleHolography.cu_apply_low_pass_filter!-Tuple{CuWavefront, CuLowPassFilter}" href="#ParticleHolography.cu_apply_low_pass_filter!-Tuple{CuWavefront, CuLowPassFilter}"><code>ParticleHolography.cu_apply_low_pass_filter!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cu_apply_low_pass_filter!(holo, lpf)</code></pre><p>Apply a low pass filter to the wavefront <code>holo</code>. The low pass filter is applied by multiplying the Fourier transform of the wavefront with the Fourier transform of the low pass filter. The wavefront is then reconstructed by taking the inverse Fourier transform of the filtered Fourier transform.</p><p><strong>Arguments</strong></p><ul><li><code>holo::CuWavefront</code>: The wavefront to apply the low pass filter.</li><li><code>lpf::CuLowPassFilter</code>: The low pass filter to apply to the wavefront.</li></ul><p><strong>Returns</strong></p><ul><li><code>nothing</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dainakai/ParticleHolography.jl/blob/daf5c5b0b2f5ab0da18923971d43f8be504941eb/src/frequency_filters.jl#L76-L87">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ParticleHolography.cu_apply_low_pass_filter-Tuple{CuWavefront, CuLowPassFilter}" href="#ParticleHolography.cu_apply_low_pass_filter-Tuple{CuWavefront, CuLowPassFilter}"><code>ParticleHolography.cu_apply_low_pass_filter</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cu_apply_low_pass_filter(holo, lpf)</code></pre><p>Apply a low pass filter to the wavefront <code>holo</code>. The low pass filter is applied by multiplying the Fourier transform of the wavefront with the Fourier transform of the low pass filter. The wavefront is then reconstructed by taking the inverse Fourier transform of the filtered Fourier transform.</p><p><strong>Arguments</strong></p><ul><li><code>holo::CuWavefront</code>: The wavefront to apply the low pass filter.</li><li><code>lpf::CuLowPassFilter</code>: The low pass filter to apply to the wavefront.</li></ul><p><strong>Returns</strong></p><ul><li><code>CuWavefront{ComplexF32}</code>: The wavefront after applying the low pass filter.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dainakai/ParticleHolography.jl/blob/daf5c5b0b2f5ab0da18923971d43f8be504941eb/src/frequency_filters.jl#L93-L104">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ParticleHolography.cu_connected_component_labeling-Tuple{Any}" href="#ParticleHolography.cu_connected_component_labeling-Tuple{Any}"><code>ParticleHolography.cu_connected_component_labeling</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cu_connected_component_labeling(input_img)</code></pre><p>8-way connected component labeling on binary image based on the article by Playne and Hawick https://ieeexplore.ieee.org/document/8274991 and the implementation by FolkeV https://github.com/FolkeV/CUDA_CCL. It works using the CUDA.jl package and NVIDIA GPUs.</p><p><strong>Arguments</strong></p><ul><li><code>input_img::CuArray{Float32, 2}</code>: Input binary image. </li></ul><p><strong>Returns</strong></p><ul><li><code>output_img::CuArray{UInt32, 2}</code>: Output labeled image.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dainakai/ParticleHolography.jl/blob/daf5c5b0b2f5ab0da18923971d43f8be504941eb/src/ccl.jl#L174-L185">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ParticleHolography.cu_gabor_wavefront-Tuple{CUDA.CuArray{Float32, 2}}" href="#ParticleHolography.cu_gabor_wavefront-Tuple{CUDA.CuArray{Float32, 2}}"><code>ParticleHolography.cu_gabor_wavefront</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cu_gabor_wavefront(holo)</code></pre><p>Create a wavefront from single hologram <code>holo</code>. This is for Gabor holography. The wavefront is created by taking the square root of the hologram and casting it to a complex number.</p><p><strong>Arguments</strong></p><ul><li><code>holo::CuArray{Float32,2}</code>: The hologram to create the wavefront from.</li></ul><p><strong>Returns</strong></p><ul><li><code>CuWavefront{ComplexF32}</code>: The wavefront created from the hologram. See <a href="#ParticleHolography.CuWavefront"><code>CuWavefront</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dainakai/ParticleHolography.jl/blob/daf5c5b0b2f5ab0da18923971d43f8be504941eb/src/holofunc.jl#L68-L78">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ParticleHolography.cu_get_reconst_complex_vol-Tuple{CuWavefront{ComplexF32}, CuTransfer{ComplexF32}, CuTransfer{ComplexF32}, Int64}" href="#ParticleHolography.cu_get_reconst_complex_vol-Tuple{CuWavefront{ComplexF32}, CuTransfer{ComplexF32}, CuTransfer{ComplexF32}, Int64}"><code>ParticleHolography.cu_get_reconst_complex_vol</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cu_get_reconst_complex_vol(holo, transfer_front, transfer_dz, slices)</code></pre><p>Reconstruct the observation volume from the <code>wavefront</code> using the transfer functions <code>transfer_front</code> and <code>transfer_dz</code> and return the complex amplitude volume. <code>transfer_front</code> propagates the wavefront to the front of the volume, and <code>transfer_dz</code> propagates the wavefront between the slices. <code>slices</code> is the number of slices in the volume.</p><p><strong>Arguments</strong></p><ul><li><code>wavefront::CuArray{ComplexF32,2}</code>: The wavefront to reconstruct. In Gabor&#39;s holography, this is the square root of the hologram.</li><li><code>transfer_front::CuTransfer{ComplexF32}</code>: The transfer function to propagate the wavefront to the front of the volume. See <a href="#ParticleHolography.CuTransfer"><code>CuTransfer</code></a>.</li><li><code>transfer_dz::CuTransfer{ComplexF32}</code>: The transfer function to propagate the wavefront between the slices.</li><li><code>slices::Int</code>: The number of slices in the volume.</li></ul><p><strong>Returns</strong></p><ul><li><code>CuArray{ComplexF32,3}</code>: The reconstructed complex amplitude volume.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dainakai/ParticleHolography.jl/blob/daf5c5b0b2f5ab0da18923971d43f8be504941eb/src/holofunc.jl#L183-L196">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ParticleHolography.cu_get_reconst_vol" href="#ParticleHolography.cu_get_reconst_vol"><code>ParticleHolography.cu_get_reconst_vol</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cu_get_reconst_vol(holo, transfer_front, transfer_dz, slices, return_type)</code></pre><p>Reconstruct the observation volume from the <code>wavefront</code> using the transfer functions <code>transfer_front</code> and <code>transfer_dz</code>. <code>transfer_front</code> propagates the wavefront to the front of the volume, and <code>transfer_dz</code> propagates the wavefront between the slices. <code>slices</code> is the number of slices in the volume.</p><p><strong>Arguments</strong></p><ul><li><code>wavefront::CuArray{ComplexF32,2}</code>: The wavefront to reconstruct. In Gabor&#39;s holography, this is the square root of the hologram.</li><li><code>transfer_front::CuTransfer{ComplexF32}</code>: The transfer function to propagate the wavefront to the front of the volume. See <a href="#ParticleHolography.CuTransfer"><code>CuTransfer</code></a>.</li><li><code>transfer_dz::CuTransfer{ComplexF32}</code>: The transfer function to propagate the wavefront between the slices.</li><li><code>slices::Int</code>: The number of slices in the volume.</li><li><code>return_type::Type</code>: The return type of the reconstructed volume. Default is <code>N0f8</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>CuArray{return_type,3}</code>: The reconstructed intensity volume.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dainakai/ParticleHolography.jl/blob/daf5c5b0b2f5ab0da18923971d43f8be504941eb/src/holofunc.jl#L150-L164">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ParticleHolography.cu_get_reconst_vol_and_xyprojection" href="#ParticleHolography.cu_get_reconst_vol_and_xyprojection"><code>ParticleHolography.cu_get_reconst_vol_and_xyprojection</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cu_get_reconst_vol_and_xyprojection(wavefront, transfer_front, transfer_dz, slices, return_type)</code></pre><p>Reconstruct the observation volume from the <code>wavefront</code> and get the XY projection of the volume using the transfer functions <code>transfer_front</code> and <code>transfer_dz</code>. <code>transfer_front</code> propagates the wavefront to the front of the volume, and <code>transfer_dz</code> propagates the wavefront between the slices. <code>slices</code> is the number of slices in the volume.</p><p><strong>Arguments</strong></p><ul><li><code>wavefront::CuWavefront{ComplexF32}</code>: The wavefront to reconstruct. In Gabor&#39;s holography, this is the square root of the hologram.</li><li><code>transfer_front::CuTransfer{ComplexF32}</code>: The transfer function to propagate the wavefront to the front of the volume. See <a href="#ParticleHolography.CuTransfer"><code>CuTransfer</code></a>.</li><li><code>transfer_dz::CuTransfer{ComplexF32}</code>: The transfer function to propagate the wavefront between the slices.</li><li><code>slices::Int</code>: The number of slices in the volume.</li><li><code>return_type::Type</code>: The return type of the reconstructed volume. Default is <code>N0f8</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>CuArray{return_type,3}</code>: The reconstructed volume.</li><li><code>CuArray{Float32,2}</code>: The XY projection of the reconstructed volume.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dainakai/ParticleHolography.jl/blob/daf5c5b0b2f5ab0da18923971d43f8be504941eb/src/holofunc.jl#L265-L280">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ParticleHolography.cu_get_reconst_xyprojection-Tuple{CuWavefront{ComplexF32}, CuTransfer{ComplexF32}, CuTransfer{ComplexF32}, Int64}" href="#ParticleHolography.cu_get_reconst_xyprojection-Tuple{CuWavefront{ComplexF32}, CuTransfer{ComplexF32}, CuTransfer{ComplexF32}, Int64}"><code>ParticleHolography.cu_get_reconst_xyprojection</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cu_get_reconst_xyprojectin(wavefront, transfer_front, transfer_dz, slices)</code></pre><p>Get the XY projection of the reconstructed volume from the <code>wavefront</code> using the transfer functions <code>transfer_front</code> and <code>transfer_dz</code>. <code>transfer_front</code> propagates the wavefront to the front of the volume, and <code>transfer_dz</code> propagates the wavefront between the slices. <code>slices</code> is the number of slices in the volume.</p><p><strong>Arguments</strong></p><ul><li><code>wavefront::CuWavefront{ComplexF32}</code>: The wavefront to reconstruct. In Gabor&#39;s holography, this is the square root of the hologram.</li><li><code>transfer_front::CuTransfer{ComplexF32}</code>: The transfer function to propagate the wavefront to the front of the volume. See <a href="#ParticleHolography.CuTransfer"><code>CuTransfer</code></a>.</li><li><code>transfer_dz::CuTransfer{ComplexF32}</code>: The transfer function to propagate the wavefront between the slices.</li><li><code>slices::Int</code>: The number of slices in the volume.</li></ul><p><strong>Returns</strong></p><ul><li><code>CuArray{Float32,2}</code>: The XY projection of the reconstructed volume.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dainakai/ParticleHolography.jl/blob/daf5c5b0b2f5ab0da18923971d43f8be504941eb/src/holofunc.jl#L215-L228">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ParticleHolography.cu_phase_retrieval_holo-Tuple{CUDA.CuArray{Float32, 2}, CUDA.CuArray{Float32, 2}, CuTransfer{ComplexF32}, CuTransfer{ComplexF32}, Int64, Int64}" href="#ParticleHolography.cu_phase_retrieval_holo-Tuple{CUDA.CuArray{Float32, 2}, CUDA.CuArray{Float32, 2}, CuTransfer{ComplexF32}, CuTransfer{ComplexF32}, Int64, Int64}"><code>ParticleHolography.cu_phase_retrieval_holo</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cu_phase_retrieval_holo(holo1, holo2, transfer, invtransfer, priter, datlen)</code></pre><p>Perform the Gerchberg-Saxton algorithm-based phase retrieving on two holograms and return the retrieved wavefront at the z-coordinate point of <code>holo1</code>. The algorithm is repeated <code>priter</code> times. <code>holo1</code> and <code>holo2</code> are the holograms (I = |phi|^2) of the object at two different z-coordinates. <code>transfer</code> and <code>invtransfer</code> are the transfer functions for the propagation from <code>holo1</code> to <code>holo2</code> and vice versa. <code>datlen</code> is the size of the holograms.</p><p><strong>Arguments</strong></p><ul><li><code>holo1::CuArray{Float32,2}</code>: The hologram at the z-cordinate of closer to the object.</li><li><code>holo2::CuArray{Float32,2}</code>: The hologram at the z-coordinate of further from the object.</li><li><code>transfer::CuTransfer{ComplexF32}</code>: The transfer function from <code>holo1</code> to <code>holo2</code>.</li><li><code>invtransfer::CuTransfer{ComplexF32}</code>: The transfer function from <code>holo2</code> to <code>holo1</code>.</li><li><code>priter::Int</code>: The number of iterations to perform the algorithm.</li><li><code>datlen::Int</code>: The size of the holograms.</li></ul><p><strong>Returns</strong></p><ul><li><code>CuWavefront{ComplexF32}</code>: The retrieved wavefront at the z-coordinate of <code>holo1</code>. See <a href="#ParticleHolography.CuWavefront"><code>CuWavefront</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dainakai/ParticleHolography.jl/blob/daf5c5b0b2f5ab0da18923971d43f8be504941eb/src/holofunc.jl#L83-L98">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ParticleHolography.cu_rectangle_filter-Tuple{AbstractFloat, AbstractFloat, Int64, AbstractFloat}" href="#ParticleHolography.cu_rectangle_filter-Tuple{AbstractFloat, AbstractFloat, Int64, AbstractFloat}"><code>ParticleHolography.cu_rectangle_filter</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cu_rectangle_filter(prop_dist::AbstractFloat, wavlen::AbstractFloat, imglen::Int, pixel_picth::AbstractFloat)</code></pre><p>Creates a low pass filter with a rectangular window. This can be multiplied with the Fourier transform of wavefront to get the low pass filtered wavefront. See Eq. 13 and 14 in (Fugal, 2009, https://doi.org/10.1088/0957-0233/20/7/075501)</p><p><strong>Arguments</strong></p><ul><li><code>prop_dist::AbstractFloat</code>: The maximum propagation distance of recorded objects.</li><li><code>wavlen::AbstractFloat</code>: The wavelength of the light.</li><li><code>imglen::Int</code>: The length of the image.</li><li><code>pixel_picth::AbstractFloat</code>: The pixel pitch of the image.</li></ul><p><strong>Returns</strong></p><ul><li><code>CuLowPassFilter</code>: The low pass filter as a CuLowPassFilter object.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dainakai/ParticleHolography.jl/blob/daf5c5b0b2f5ab0da18923971d43f8be504941eb/src/frequency_filters.jl#L17-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ParticleHolography.cu_super_gaussian_filter-Tuple{AbstractFloat, AbstractFloat, Int64, AbstractFloat}" href="#ParticleHolography.cu_super_gaussian_filter-Tuple{AbstractFloat, AbstractFloat, Int64, AbstractFloat}"><code>ParticleHolography.cu_super_gaussian_filter</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cu_super_gaussian_filter(prop_dist::AbstractFloat, wavlen::AbstractFloat, imglen::Int, pixel_picth::AbstractFloat)</code></pre><p>Creates a low pass filter with a super Gaussian window. This can be multiplied with the Fourier transform of wavefront to get the low pass filtered wavefront. See Eq. 15 in (Fugal, 2009, https://doi.org/10.1088/0957-0233/20/7/075501)</p><p><strong>Arguments</strong></p><ul><li><code>prop_dist::AbstractFloat</code>: The maximum propagation distance of recorded objects.</li><li><code>wavlen::AbstractFloat</code>: The wavelength of the light.</li><li><code>imglen::Int</code>: The length of the image.</li><li><code>pixel_picth::AbstractFloat</code>: The pixel pitch of the image.</li></ul><p><strong>Returns</strong></p><ul><li><code>CuLowPassFilter</code>: The low pass filter as a CuLowPassFilter object.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dainakai/ParticleHolography.jl/blob/daf5c5b0b2f5ab0da18923971d43f8be504941eb/src/frequency_filters.jl#L52-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ParticleHolography.cu_transfer-Tuple{AbstractFloat, Int64, AbstractFloat, CuTransferSqrtPart{Float32}}" href="#ParticleHolography.cu_transfer-Tuple{AbstractFloat, Int64, AbstractFloat, CuTransferSqrtPart{Float32}}"><code>ParticleHolography.cu_transfer</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cu_transfer(z0, datLen, wavLen, d_sqr)</code></pre><p>Create a CuArray of size <code>datLen</code> x <code>datLen</code> with the values of the transfer function for a given propagated distance z0. <code>d_sqr</code> can be obtained with <code>cutransfersqrtarr(datlen, wavlen, dx)</code>.</p><p><strong>Arguments</strong></p><ul><li><code>z0::AbstractFloat</code>: The distance to propagate the wave.</li><li><code>datLen::Int</code>: The size of the CuArray.</li><li><code>wavLen::AbstractFloat</code>: The wavelength of the light.</li><li><code>d_sqr::::CuTransferSqrtPart{Float32}</code>: The square of the distance from the center of the hologram, obtained with <code>cutransfersqrtarr(datlen, wavlen, dx)</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>CuTransfer{Float32}</code>: The transfer function for the propagation. See <a href="#ParticleHolography.CuTransfer"><code>CuTransfer</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dainakai/ParticleHolography.jl/blob/daf5c5b0b2f5ab0da18923971d43f8be504941eb/src/holofunc.jl#L46-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ParticleHolography.cu_transfer_sqrt_arr-Tuple{Int64, AbstractFloat, AbstractFloat}" href="#ParticleHolography.cu_transfer_sqrt_arr-Tuple{Int64, AbstractFloat, AbstractFloat}"><code>ParticleHolography.cu_transfer_sqrt_arr</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cu_transfer_sqrt_arr(datlen, wavlen, dx)</code></pre><p>Create a CuArray of size <code>datlen</code> x <code>datlen</code> with the values of the square-root part of the transfer function.</p><p><strong>Arguments</strong></p><ul><li><code>datlen::Int</code>: The size of the CuArray.</li><li><code>wavlen::AbstractFloat</code>: The wavelength of the light.</li><li><code>dx::AbstractFloat</code>: The pixel size of the hologram.</li></ul><p><strong>Returns</strong></p><ul><li><code>CuTransferSqrtPart{Float32}</code>: The square-root part of the transfer function. See <a href="#ParticleHolography.CuTransferSqrtPart"><code>CuTransferSqrtPart</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dainakai/ParticleHolography.jl/blob/daf5c5b0b2f5ab0da18923971d43f8be504941eb/src/holofunc.jl#L16-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ParticleHolography.dictload-Tuple{Any}" href="#ParticleHolography.dictload-Tuple{Any}"><code>ParticleHolography.dictload</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dictload(filename)</code></pre><p>Load a particle dictionary from a file in JSON format. The dictionary should have UUID keys and values as Vector{Float32}, which includes the coordinates (and diameters) of the particles.</p><p><strong>Arguments</strong></p><ul><li><code>filename::String</code>: The path to the file.</li></ul><p><strong>Returns</strong></p><ul><li><code>Dict</code>: The loaded dictionary.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dainakai/ParticleHolography.jl/blob/daf5c5b0b2f5ab0da18923971d43f8be504941eb/src/utils.jl#L254-L264">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ParticleHolography.dictsave-Tuple{Any, Dict}" href="#ParticleHolography.dictsave-Tuple{Any, Dict}"><code>ParticleHolography.dictsave</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dictsave(filename, dict)</code></pre><p>Save a particle dictionary to a file in JSON format. The dictionary should have UUID keys and values as Vector{Float32}, which includes the coordinates (and diameters) of the particles.</p><p><strong>Arguments</strong></p><ul><li><code>filename::String</code>: The path to the file.</li><li><code>dict::Dict</code>: The dictionary to save.</li></ul><p><strong>Returns</strong></p><ul><li><code>nothing</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dainakai/ParticleHolography.jl/blob/daf5c5b0b2f5ab0da18923971d43f8be504941eb/src/utils.jl#L235-L246">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ParticleHolography.enum_edge" href="#ParticleHolography.enum_edge"><code>ParticleHolography.enum_edge</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">enum_edge(g::MetaGraph)</code></pre><p>Enumerates all edges in the given <code>MetaGraph</code> <code>g</code> and returns them as an array of arrays of UUIDs. Each inner array contains the labels of the source and destination nodes of an edge.</p><p><strong>Arguments</strong></p><ul><li><code>g::MetaGraph</code>: The <code>MetaGraph</code> to enumerate edges from.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{UUID}[]</code>: An array of arrays of UUIDs, where each inner array contains the labels of the source and destination nodes of an edge.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dainakai/ParticleHolography.jl/blob/daf5c5b0b2f5ab0da18923971d43f8be504941eb/src/particle_tracking.jl#L220-L230">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ParticleHolography.finalize_particle_neighborhoods!-Tuple{Any}" href="#ParticleHolography.finalize_particle_neighborhoods!-Tuple{Any}"><code>ParticleHolography.finalize_particle_neighborhoods!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">finalize_particle_neighborhoods!(particle_neighborhoods)</code></pre><p>Finalizes the particle neighborhoods by removing duplicates and particles that are too small or too elongated in the x-y plane. Detailed criteria are as follows:</p><ul><li>Duplicate bounding boxes</li><li>Bounding boxes with a length-to-width (x-y) ratio greater than 3 or less than 1/3</li><li>Bounding boxes with an area less than <span>$\sqrt{10}$</span> pixels</li><li>Bounding boxes with a depth of 1</li></ul><p><strong>Arguments</strong></p><ul><li><code>particle_neighborhoods</code>: The particle neighborhoods to be finalized.</li></ul><p><strong>Returns</strong></p><ul><li><code>nothing</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dainakai/ParticleHolography.jl/blob/daf5c5b0b2f5ab0da18923971d43f8be504941eb/src/ccl.jl#L350-L365">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ParticleHolography.find_external_contours-Tuple{Any}" href="#ParticleHolography.find_external_contours-Tuple{Any}"><code>ParticleHolography.find_external_contours</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_external_contours(image)</code></pre><p>Finds non-hole contours in binary images. This function is excuted on the CPU. Equivalent to CV<em>RETR</em>EXTERNAL and CV<em>CHAIN</em>APPROX_NONE modes of the findContours() function provided in OpenCV.</p><p><strong>Arguments</strong></p><ul><li><code>image</code>: The binary image. the image should be a 2D array of 0 and 1.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Vector{CartesianIndex}}</code>: A vector of contours. Each contour is a vector of CartesianIndex.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dainakai/ParticleHolography.jl/blob/daf5c5b0b2f5ab0da18923971d43f8be504941eb/src/utils.jl#L110-L120">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ParticleHolography.gen_fulldict-Tuple{Vector{Dict{Base.UUID, Vector{Float32}}}}" href="#ParticleHolography.gen_fulldict-Tuple{Vector{Dict{Base.UUID, Vector{Float32}}}}"><code>ParticleHolography.gen_fulldict</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gen_fulldict(dicts::Vector{Dict{UUID, Vector{Float32}}})</code></pre><p>Generates a dictionary containing the UUIDs of particles for all conceivable frames as keys and their coordinates as values. The input is a vector of dictionaries with UUID keys and values as Vector{Float32}, which includes the coordinates (and diameters) of the particles.</p><p><strong>Arguments</strong></p><ul><li><code>dicts::Vector{Dict{UUID, Vector{Float32}}}</code>: Vector of dictionaries with UUID keys and values as Vector{Float32}.</li></ul><p><strong>Returns</strong></p><ul><li><code>Dict{UUID, Vector{Float32}}</code>: Dictionary containing the UUIDs of particles for all conceivable frames as keys and their coordinates as values.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dainakai/ParticleHolography.jl/blob/daf5c5b0b2f5ab0da18923971d43f8be504941eb/src/particle_tracking.jl#L296-L306">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ParticleHolography.gen_fulldict-Tuple{Vector{String}}" href="#ParticleHolography.gen_fulldict-Tuple{Vector{String}}"><code>ParticleHolography.gen_fulldict</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gen_fulldict(filepaths::Vector{String})</code></pre><p>Generates a dictionary containing the UUIDs of particles for all conceivable frames as keys and their coordinates as values. The input is a vector of file paths containing JSON files with particle coordinates.</p><p><strong>Arguments</strong></p><ul><li><code>filepaths::Vector{String}</code>: Vector of file paths containing JSON files with particle coordinates.</li></ul><p><strong>Returns</strong></p><ul><li><code>Dict{UUID, Vector{Float32}}</code>: Dictionary containing the UUIDs of particles for all conceivable frames as keys and their coordinates as values.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dainakai/ParticleHolography.jl/blob/daf5c5b0b2f5ab0da18923971d43f8be504941eb/src/particle_tracking.jl#L272-L282">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ParticleHolography.getErrorVec" href="#ParticleHolography.getErrorVec"><code>ParticleHolography.getErrorVec</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getErrorVec(vecMap, coefa, gridSize = 128, imgSize = 1024)

Return the vector `errorVec` obtained by calculating the difference between `targetX` `targetY` and `procX` `procY` obtained by converting `targetX` `targetY` from the `gridx` `gridy` set in the first image to the second image. Also returns `gridx` `gridy` for Jacobian acquisition.</code></pre><p><strong>Arguments</strong></p><ul><li><code>vecMap</code>: The PIV map.</li><li><code>coefa</code>: The coefficients for the quadratic distortion correction.</li><li><code>gridSize</code>: The size of the grid.</li><li><code>imgSize</code>: The size of the image.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dainakai/ParticleHolography.jl/blob/daf5c5b0b2f5ab0da18923971d43f8be504941eb/src/bundleadjustment.jl#L189-L199">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ParticleHolography.getYacobian" href="#ParticleHolography.getYacobian"><code>ParticleHolography.getYacobian</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getYacobian(imgSize = 1024, gridSize = 128)</code></pre><p>Get the Jacobian matrix for the quadratic distortion correction. The default image size is 1024, and the grid size is 128.</p><p><strong>Arguments</strong></p><ul><li><code>imgSize::Int</code>: The size of the image.</li><li><code>gridSize::Int</code>: The size of the grid.</li></ul><p><strong>Returns</strong></p><ul><li><code>Array{Float64,2}</code>: The Jacobian matrix.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dainakai/ParticleHolography.jl/blob/daf5c5b0b2f5ab0da18923971d43f8be504941eb/src/bundleadjustment.jl#L127-L138">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ParticleHolography.get_distortion_coefficients-Tuple{Matrix{&lt;:AbstractFloat}, Matrix{&lt;:AbstractFloat}}" href="#ParticleHolography.get_distortion_coefficients-Tuple{Matrix{&lt;:AbstractFloat}, Matrix{&lt;:AbstractFloat}}"><code>ParticleHolography.get_distortion_coefficients</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_distortion_coeficients(img1, img2, gridSize = 128, intrSize = 128, srchSize = 256)</code></pre><p>Get the distortion coefficients from the two images <code>img1</code> and <code>img2</code>. The default grid size is 128, the default search size is 256, and the default image size is 128.</p><p><strong>Arguments</strong></p><ul><li><code>img1::Array{&lt;:AbstractFloat,2}</code>: The first image.</li><li><code>img2::Array{&lt;:AbstractFloat,2}</code>: The second image.</li><li><code>gridSize::Int</code>: The size of the grid.</li><li><code>intrSize::Int</code>: The size of the search.</li><li><code>srchSize::Int</code>: The size of the search.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{&lt;:AbstractFloat}</code>: The distortion coefficients.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dainakai/ParticleHolography.jl/blob/daf5c5b0b2f5ab0da18923971d43f8be504941eb/src/bundleadjustment.jl#L331-L345">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ParticleHolography.load_gray2float-Tuple{String}" href="#ParticleHolography.load_gray2float-Tuple{String}"><code>ParticleHolography.load_gray2float</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">load_gray2float(path)</code></pre><p>Load a grayscale image from a file and return it as a Array{Float32, 2} array.</p><p><strong>Arguments</strong></p><ul><li><code>path::String</code>: The path to the image file.</li></ul><p><strong>Returns</strong></p><ul><li><code>Array{Float32, 2}</code>: The image as a Float32 array.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dainakai/ParticleHolography.jl/blob/daf5c5b0b2f5ab0da18923971d43f8be504941eb/src/utils.jl#L11-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ParticleHolography.make_background-Tuple{Vector{String}}" href="#ParticleHolography.make_background-Tuple{Vector{String}}"><code>ParticleHolography.make_background</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">make_background(pathlist; mode=:mode)</code></pre><p>Make a background image from a list of image paths. The background image is calculated by taking the mean or mode of the images in the list. The default mode is :mode.</p><p><strong>Arguments</strong></p><ul><li><code>pathlist::Vector{String}</code>: A list of image paths. <code>glob()</code> can be used to generate this list.</li><li><code>mode::Symbol</code>: The mode to use for calculating the background. Options are :mean or :mode. Default is :mode.</li></ul><p><strong>Returns</strong></p><ul><li><code>Array{Float64, 2}</code>: The background image.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dainakai/ParticleHolography.jl/blob/daf5c5b0b2f5ab0da18923971d43f8be504941eb/src/utils.jl#L189-L200">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ParticleHolography.modified_Cholesky_decomposition-Tuple{Matrix{&lt;:AbstractFloat}}" href="#ParticleHolography.modified_Cholesky_decomposition-Tuple{Matrix{&lt;:AbstractFloat}}"><code>ParticleHolography.modified_Cholesky_decomposition</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">modified_Cholesky_decomposition(A)</code></pre><p>This function decomposes the target matrix A to A = LDL^T. The diagonal components of the return matrix are the inverse of D, and the lower left components correspond to L. 対象行列Aを A = LDL^T に変換します。戻り値行列の対角成分は D の逆数、左下成分は L に一致します。</p><p><strong>Arguments</strong></p><ul><li><code>A::Array{&lt;:AbstractFloat,2}</code>: The target matrix.</li></ul><p><strong>Returns</strong></p><ul><li><code>Array{AbstractFloat,2}</code>: The decomposed matrix.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dainakai/ParticleHolography.jl/blob/daf5c5b0b2f5ab0da18923971d43f8be504941eb/src/bundleadjustment.jl#L51-L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ParticleHolography.node_distance" href="#ParticleHolography.node_distance"><code>ParticleHolography.node_distance</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">node_distance(node1, node2, dim3weight=0.01)</code></pre><p>Calculates the Euclidean distance between two nodes in a 3D space.</p><p><strong>Arguments</strong></p><ul><li><code>node1</code>: Coordinates of the first node.</li><li><code>node2</code>: Coordinates of the second node.</li><li><code>dim3weight=0.01</code>: Scaling factor for the third dimension. For holographic particle tracking, the third dimension is often less accurate than the first two dimensions, so it is scaled down..</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dainakai/ParticleHolography.jl/blob/daf5c5b0b2f5ab0da18923971d43f8be504941eb/src/particle_tracking.jl#L8-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ParticleHolography.particle_bounding_boxes-Tuple{CUDA.CuArray{Bool, 3}}" href="#ParticleHolography.particle_bounding_boxes-Tuple{CUDA.CuArray{Bool, 3}}"><code>ParticleHolography.particle_bounding_boxes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">particle_bounding_boxes(d_bin_vol)</code></pre><p>Detects the particles in a binary volume and returns the bounding boxes of the particles. This function performs three-dimensional element connected labeling on binary volumes. However, please note that it does not perform strict adjacent connectivity in the optical axis (z) direction. Strict adjacent connectivity in the optical axis direction may result in artifacts not being connected, potentially leading to the detection of many ghost particles. This function assumes that two particles never overlap at exactly the same X-Y coordinates. All elements that overlap in X-Y coordinates are considered connected. Therefore, this method is not suitable for accurate position detection of particles that overlap in X-Y coordinates. Additionally, this processing may have some effects, such as slightly elongating the bounding box of particles in the optical axis direction. However, this has minimal impact on the accuracy of particle position detection.</p><p><strong>Arguments</strong></p><ul><li><code>d_bin_vol::CuArray{Bool, 3}</code>: The binary volume of reconstructed holographic volume. Binarization can be done by thresholding the reconstructed volume. <code>true</code> values represent the particles and neighboring voxels and vice versa.</li></ul><p><strong>Returns</strong></p><ul><li><code>Dict{UUID, Vector{Int}}</code>: The bounding boxes of the particles.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dainakai/ParticleHolography.jl/blob/daf5c5b0b2f5ab0da18923971d43f8be504941eb/src/particle_detection.jl#L32-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ParticleHolography.particle_coor_diams" href="#ParticleHolography.particle_coor_diams"><code>ParticleHolography.particle_coor_diams</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">particle_coor_diams(particle_bbs, d_vol, d_lpf_vol = nothing; depth_metrics = tamura, profile_smoothing_kernel = Kernel.gaussian(5,), diameter_metrics = equivalent_diameter)</code></pre><p>Calculates the coordinates and diameters of the particles in the reconstructed volume with the bounding boxe dictionary. The depth of the particles is the maximum of the profile that is calculated using the <code>depth_metrics</code> function at each slice of the bounding box. The profile is then smoothed using the <code>profile_smoothing_kernel</code>. The x and y coordinates are calculated by finding the center of mass of the slice with the detected depth. The low pass filtered volume would be better for coordinate detection. The diameter of the particles is calculated using the <code>diameter_metrics</code> function. If the low pass filtered volume is provided, the coordinate is calculated using the low pass filtered volume.</p><p><strong>Arguments</strong></p><ul><li><code>particle_bbs::Dict{UUID, Vector{Int}}</code>: The bounding boxes of the particles.</li><li><code>d_vol::CuArray{N0f8, 3}</code>: The reconstructed volume.</li></ul><p><strong>Optional arguments</strong></p><ul><li><code>d_lpf_vol::Union{CuArray{N0f8,3}, Nothing} = nothing</code>: The low pass filtered volume.</li></ul><p><strong>Optional keyword arguments</strong></p><ul><li><code>depth_metrics::Function = tamura</code>: The function that calculates the depth profile of the particles.</li><li><code>profile_smoothing_kernel = Kernel.gaussian((5,))</code>: The kernel used for smoothing the depth profile.</li><li><code>diameter_metrics::Function = equivalent_diameter</code>: The function that calculates the diameter of the particles.</li></ul><p><strong>Returns</strong></p><ul><li><code>Dict{UUID, Vector{Float32}}</code>: The coordinates and diameters of the particles.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dainakai/ParticleHolography.jl/blob/daf5c5b0b2f5ab0da18923971d43f8be504941eb/src/particle_detection.jl#L133-L152">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ParticleHolography.particle_coordinates-Tuple{Dict{Base.UUID, Vector{Int64}}, CUDA.CuArray{FixedPointNumbers.N0f8, 3}}" href="#ParticleHolography.particle_coordinates-Tuple{Dict{Base.UUID, Vector{Int64}}, CUDA.CuArray{FixedPointNumbers.N0f8, 3}}"><code>ParticleHolography.particle_coordinates</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">particle_coordinates(particle_bbs, d_vol; depth_metrics = tamura, profile_smoothing_kernel = Kernel.gaussian(5,))</code></pre><p>Calculates the coordinates of the particles in the reconstructed volume with the bounding boxe dictionary. The depth of the particles is the maximum of the profile that is calculated using the <code>depth_metrics</code> function at each slice of the bounding box. The profile is then smoothed using the <code>profile_smoothing_kernel</code>. The x and y coordinates are calculated by finding the center of mass of the slice with the detected depth. The low pass filtered volume would be better for coordinate detection.</p><p><strong>Arguments</strong></p><ul><li><code>particle_bbs::Dict{UUID, Vector{Int}}</code>: The bounding boxes of the particles.</li><li><code>d_vol::CuArray{N0f8, 3}</code>: The reconstructed volume.</li><li><code>depth_metrics::Function = tamura</code>: The function that calculates the depth profile of the particles.</li><li><code>profile_smoothing_kernel = Kernel.gaussian((5,))</code>: The kernel used for smoothing the depth profile.</li></ul><p><strong>Returns</strong></p><ul><li><code>Dict{UUID, Vector{Float32}}</code>: The coordinates of the particles.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dainakai/ParticleHolography.jl/blob/daf5c5b0b2f5ab0da18923971d43f8be504941eb/src/particle_detection.jl#L100-L113">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ParticleHolography.particleplot!-Tuple" href="#ParticleHolography.particleplot!-Tuple"><code>ParticleHolography.particleplot!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">particleplot(data::Dict{UUID, Vector{Float32}}; scaling=(1.0, 1.0, -1.0), shift=(0.0, 0.0, 0.0), kwargs...)
particleplot!(data::Dict{UUID, Vector{Float32}}; scaling=(1.0, 1.0, -1.0), shift=(0.0, 0.0, 0.0), kwargs...)</code></pre><p>Plots the particles in the 3D space. The data should be a dictionary with UUID keys and values as Vector{Float32}, which includes the coordinates of the particles. The scaling and shift parameters are used to transform the coordinates to the observed space.</p><p>In this plot, we display the x-y plane in the foreground by mapping the data&#39;s z-axis to the y-axis of Plots.scatter(). To align the data&#39;s y-axis with the hologram image coordinates, we set zflip = true by default. This results in a left-handed coordinate system, so we additionally set yflip = true to correct for this. The z-coordinate of the data (slice number) is opposite to the optical axis direction shown in the <a href="../whats_inline_holography/#introduction">Introduction</a>, so we set the z-axis data scaling to -1.0 for correct display.</p><p><strong>Arguments</strong></p><ul><li><code>data::Dict{UUID, Vector{Float32}}</code>: The coordinates of the particles.</li></ul><p><strong>Optional keyword arguments</strong></p><ul><li><code>scaling::Tuple{Float32, Float32, Float32} = (1.0, 1.0, -1.0)</code>: The scaling of the coordinates.</li><li><code>shift::Tuple{Float32, Float32, Float32} = (0.0, 0.0, 0.0)</code>: The shift of the coordinates.</li><li><code>kwargs...</code>: Additional keyword arguments passed to Plots.scatter().</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dainakai/ParticleHolography.jl/blob/daf5c5b0b2f5ab0da18923971d43f8be504941eb/src/plot_recipes.jl#L4-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ParticleHolography.particleplot!-Tuple{RecipesBase.AbstractPlot, Vararg{Any}}" href="#ParticleHolography.particleplot!-Tuple{RecipesBase.AbstractPlot, Vararg{Any}}"><code>ParticleHolography.particleplot!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">particleplot(data::Dict{UUID, Vector{Float32}}; scaling=(1.0, 1.0, -1.0), shift=(0.0, 0.0, 0.0), kwargs...)
particleplot!(data::Dict{UUID, Vector{Float32}}; scaling=(1.0, 1.0, -1.0), shift=(0.0, 0.0, 0.0), kwargs...)</code></pre><p>Plots the particles in the 3D space. The data should be a dictionary with UUID keys and values as Vector{Float32}, which includes the coordinates of the particles. The scaling and shift parameters are used to transform the coordinates to the observed space.</p><p>In this plot, we display the x-y plane in the foreground by mapping the data&#39;s z-axis to the y-axis of Plots.scatter(). To align the data&#39;s y-axis with the hologram image coordinates, we set zflip = true by default. This results in a left-handed coordinate system, so we additionally set yflip = true to correct for this. The z-coordinate of the data (slice number) is opposite to the optical axis direction shown in the <a href="../whats_inline_holography/#introduction">Introduction</a>, so we set the z-axis data scaling to -1.0 for correct display.</p><p><strong>Arguments</strong></p><ul><li><code>data::Dict{UUID, Vector{Float32}}</code>: The coordinates of the particles.</li></ul><p><strong>Optional keyword arguments</strong></p><ul><li><code>scaling::Tuple{Float32, Float32, Float32} = (1.0, 1.0, -1.0)</code>: The scaling of the coordinates.</li><li><code>shift::Tuple{Float32, Float32, Float32} = (0.0, 0.0, 0.0)</code>: The shift of the coordinates.</li><li><code>kwargs...</code>: Additional keyword arguments passed to Plots.scatter().</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dainakai/ParticleHolography.jl/blob/daf5c5b0b2f5ab0da18923971d43f8be504941eb/src/plot_recipes.jl#L4-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ParticleHolography.particleplot-Tuple" href="#ParticleHolography.particleplot-Tuple"><code>ParticleHolography.particleplot</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">particleplot(data::Dict{UUID, Vector{Float32}}; scaling=(1.0, 1.0, -1.0), shift=(0.0, 0.0, 0.0), kwargs...)
particleplot!(data::Dict{UUID, Vector{Float32}}; scaling=(1.0, 1.0, -1.0), shift=(0.0, 0.0, 0.0), kwargs...)</code></pre><p>Plots the particles in the 3D space. The data should be a dictionary with UUID keys and values as Vector{Float32}, which includes the coordinates of the particles. The scaling and shift parameters are used to transform the coordinates to the observed space.</p><p>In this plot, we display the x-y plane in the foreground by mapping the data&#39;s z-axis to the y-axis of Plots.scatter(). To align the data&#39;s y-axis with the hologram image coordinates, we set zflip = true by default. This results in a left-handed coordinate system, so we additionally set yflip = true to correct for this. The z-coordinate of the data (slice number) is opposite to the optical axis direction shown in the <a href="../whats_inline_holography/#introduction">Introduction</a>, so we set the z-axis data scaling to -1.0 for correct display.</p><p><strong>Arguments</strong></p><ul><li><code>data::Dict{UUID, Vector{Float32}}</code>: The coordinates of the particles.</li></ul><p><strong>Optional keyword arguments</strong></p><ul><li><code>scaling::Tuple{Float32, Float32, Float32} = (1.0, 1.0, -1.0)</code>: The scaling of the coordinates.</li><li><code>shift::Tuple{Float32, Float32, Float32} = (0.0, 0.0, 0.0)</code>: The shift of the coordinates.</li><li><code>kwargs...</code>: Additional keyword arguments passed to Plots.scatter().</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dainakai/ParticleHolography.jl/blob/daf5c5b0b2f5ab0da18923971d43f8be504941eb/src/plot_recipes.jl#L4-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ParticleHolography.quadratic_distortion_correction-Tuple{Matrix{&lt;:AbstractFloat}, Vector{&lt;:AbstractFloat}}" href="#ParticleHolography.quadratic_distortion_correction-Tuple{Matrix{&lt;:AbstractFloat}, Vector{&lt;:AbstractFloat}}"><code>ParticleHolography.quadratic_distortion_correction</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">quadratic_distortion_correction(img, coefa)</code></pre><p>Correct the quadratic distortion in the grayscale image <code>img</code> using the coefficients <code>coefa</code>. <code>img</code> have to be square, and <code>coefa</code> have to be a vector of 12 coefficients.</p><p><strong>Arguments</strong></p><ul><li><code>img::Array{&lt;:AbstractFloat,2}</code>: The image to correct.</li><li><code>coefa::Vector{&lt;:AbstractFloat}</code>: The coefficients to correct the distortion.</li></ul><p><strong>Returns</strong></p><ul><li><code>Array{AbstractFloat,2}</code>: The corrected image.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dainakai/ParticleHolography.jl/blob/daf5c5b0b2f5ab0da18923971d43f8be504941eb/src/bundleadjustment.jl#L10-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ParticleHolography.simultanious_equation_solver-Tuple{Matrix{&lt;:AbstractFloat}, Matrix{&lt;:AbstractFloat}, Vector{&lt;:AbstractFloat}}" href="#ParticleHolography.simultanious_equation_solver-Tuple{Matrix{&lt;:AbstractFloat}, Matrix{&lt;:AbstractFloat}, Vector{&lt;:AbstractFloat}}"><code>ParticleHolography.simultanious_equation_solver</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">simultanious_equation_solver(chlskyMat,yacob,errorArray)</code></pre><p>Solve the equation <code>chlskyMat</code> x = - <code>yacob</code> <code>errorArray</code> using the Cholesky decomposition matrix <code>chlskyMat</code>, Jacobian <code>yacob</code>, and error vector <code>errorArray</code>.</p><p><strong>Arguments</strong></p><ul><li><code>chlskyMat::Array{&lt;:AbstractFloat,2}</code>: The Cholesky decomposition matrix.</li><li><code>yacob::Array{&lt;:AbstractFloat,2}</code>: The Jacobian matrix.</li><li><code>errorArray::Array{&lt;:AbstractFloat,1}</code>: The error vector.</li></ul><p><strong>Returns</strong></p><ul><li><code>Array{AbstractFloat,1}</code>: The solution vector.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dainakai/ParticleHolography.jl/blob/daf5c5b0b2f5ab0da18923971d43f8be504941eb/src/bundleadjustment.jl#L88-L100">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ParticleHolography.tamura-Tuple{AbstractMatrix{&lt;:AbstractFloat}}" href="#ParticleHolography.tamura-Tuple{AbstractMatrix{&lt;:AbstractFloat}}"><code>ParticleHolography.tamura</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tamura(arr)</code></pre><p>Calculates the Tamura coefficient of an array. The Tamura coefficient is defined as the standard deviation divided by the mean of the array. Please refer to the use in digital holography https://doi.org/10.1364/OL.36.001945</p><p><strong>Arguments</strong></p><ul><li><code>arr::Array{Float32, 2}</code>: The array for which the Tamura coefficient is calculated.</li></ul><p><strong>Returns</strong></p><ul><li><code>Float32</code>: The Tamura coefficient of the array.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dainakai/ParticleHolography.jl/blob/daf5c5b0b2f5ab0da18923971d43f8be504941eb/src/particle_detection.jl#L66-L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ParticleHolography.trajectoryplot!-Tuple" href="#ParticleHolography.trajectoryplot!-Tuple"><code>ParticleHolography.trajectoryplot!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">trajectoryplot(paths::Vector{Vector{UUID}}, fulldict::Dict{UUID, Vector{Float32}}; colors=palette(:tab10), framerange=(0, 1024), scaling=(1.0, 1.0, -1.0), shift=(0.0, 0.0, 0.0), kwargs...)
trajectoryplot!(paths::Vector{Vector{UUID}}, fulldict::Dict{UUID, Vector{Float32}}; colors=palette(:tab10), framerange=(0, 1024), scaling=(1.0, 1.0, -1.0), shift=(0.0, 0.0, 0.0), kwargs...)</code></pre><p>Plots particle trajectories with different colors in 3D space. <code>paths</code> is a <code>Vector{Vector{UUID}}</code>, where each element represents the trajectory of particles considered identical. <code>fulldict</code> is a dictionary containing the UUIDs of particles for all conceivable frames as keys and their coordinates as values, generated using <a href="#ParticleHolography.gen_fulldict-Tuple{Vector{Dict{Base.UUID, Vector{Float32}}}}"><code>gen_fulldict</code></a>. <code>colors</code> specifies the palette for trajectory colors, defaulting to <code>palette(:tab10)</code>. For <code>scaling</code> and <code>shift</code>, refer to <a href="#ParticleHolography.particleplot-Tuple"><code>particleplot</code></a>. <code>framerange</code> specifies the range of frames to plot. For example, when generating <code>fulldict</code> for N consecutive frames, setting <code>framerange=(N-10+1, N)</code> will plot only the trajectories of the last 10 frames. When creating animations with the <code>@anim</code> macro, setting <code>framerange</code> from <code>(1,1)</code> to <code>(1,N)</code> will create an N-frame animation.</p><p><strong>Arguments</strong></p><ul><li><code>paths::Vector{Vector{UUID}}</code>: The trajectories of the particles.</li><li><code>fulldict::Dict{UUID, Vector{Float32}}</code>: The dictionary of all particles.</li></ul><p><strong>Optional keyword arguments</strong></p><ul><li><code>colors::Vector{Colorant} = palette(:tab10)</code>: The colors of the trajectories.</li><li><code>framerange::Tuple{Int, Int} = (0, 1024)</code>: The range of frames to plot.</li><li><code>scaling::Tuple{Float32, Float32, Float32} = (1.0, 1.0, -1.0)</code>: The scaling of the coordinates.</li><li><code>shift::Tuple{Float32, Float32, Float32} = (0.0, 0.0, 0.0)</code>: The shift of the coordinates.</li><li><code>kwargs...</code>: Additional keyword arguments passed to Plots.@series.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dainakai/ParticleHolography.jl/blob/daf5c5b0b2f5ab0da18923971d43f8be504941eb/src/plot_recipes.jl#L51-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ParticleHolography.trajectoryplot!-Tuple{RecipesBase.AbstractPlot, Vararg{Any}}" href="#ParticleHolography.trajectoryplot!-Tuple{RecipesBase.AbstractPlot, Vararg{Any}}"><code>ParticleHolography.trajectoryplot!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">trajectoryplot(paths::Vector{Vector{UUID}}, fulldict::Dict{UUID, Vector{Float32}}; colors=palette(:tab10), framerange=(0, 1024), scaling=(1.0, 1.0, -1.0), shift=(0.0, 0.0, 0.0), kwargs...)
trajectoryplot!(paths::Vector{Vector{UUID}}, fulldict::Dict{UUID, Vector{Float32}}; colors=palette(:tab10), framerange=(0, 1024), scaling=(1.0, 1.0, -1.0), shift=(0.0, 0.0, 0.0), kwargs...)</code></pre><p>Plots particle trajectories with different colors in 3D space. <code>paths</code> is a <code>Vector{Vector{UUID}}</code>, where each element represents the trajectory of particles considered identical. <code>fulldict</code> is a dictionary containing the UUIDs of particles for all conceivable frames as keys and their coordinates as values, generated using <a href="#ParticleHolography.gen_fulldict-Tuple{Vector{Dict{Base.UUID, Vector{Float32}}}}"><code>gen_fulldict</code></a>. <code>colors</code> specifies the palette for trajectory colors, defaulting to <code>palette(:tab10)</code>. For <code>scaling</code> and <code>shift</code>, refer to <a href="#ParticleHolography.particleplot-Tuple"><code>particleplot</code></a>. <code>framerange</code> specifies the range of frames to plot. For example, when generating <code>fulldict</code> for N consecutive frames, setting <code>framerange=(N-10+1, N)</code> will plot only the trajectories of the last 10 frames. When creating animations with the <code>@anim</code> macro, setting <code>framerange</code> from <code>(1,1)</code> to <code>(1,N)</code> will create an N-frame animation.</p><p><strong>Arguments</strong></p><ul><li><code>paths::Vector{Vector{UUID}}</code>: The trajectories of the particles.</li><li><code>fulldict::Dict{UUID, Vector{Float32}}</code>: The dictionary of all particles.</li></ul><p><strong>Optional keyword arguments</strong></p><ul><li><code>colors::Vector{Colorant} = palette(:tab10)</code>: The colors of the trajectories.</li><li><code>framerange::Tuple{Int, Int} = (0, 1024)</code>: The range of frames to plot.</li><li><code>scaling::Tuple{Float32, Float32, Float32} = (1.0, 1.0, -1.0)</code>: The scaling of the coordinates.</li><li><code>shift::Tuple{Float32, Float32, Float32} = (0.0, 0.0, 0.0)</code>: The shift of the coordinates.</li><li><code>kwargs...</code>: Additional keyword arguments passed to Plots.@series.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dainakai/ParticleHolography.jl/blob/daf5c5b0b2f5ab0da18923971d43f8be504941eb/src/plot_recipes.jl#L51-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ParticleHolography.trajectoryplot-Tuple" href="#ParticleHolography.trajectoryplot-Tuple"><code>ParticleHolography.trajectoryplot</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">trajectoryplot(paths::Vector{Vector{UUID}}, fulldict::Dict{UUID, Vector{Float32}}; colors=palette(:tab10), framerange=(0, 1024), scaling=(1.0, 1.0, -1.0), shift=(0.0, 0.0, 0.0), kwargs...)
trajectoryplot!(paths::Vector{Vector{UUID}}, fulldict::Dict{UUID, Vector{Float32}}; colors=palette(:tab10), framerange=(0, 1024), scaling=(1.0, 1.0, -1.0), shift=(0.0, 0.0, 0.0), kwargs...)</code></pre><p>Plots particle trajectories with different colors in 3D space. <code>paths</code> is a <code>Vector{Vector{UUID}}</code>, where each element represents the trajectory of particles considered identical. <code>fulldict</code> is a dictionary containing the UUIDs of particles for all conceivable frames as keys and their coordinates as values, generated using <a href="#ParticleHolography.gen_fulldict-Tuple{Vector{Dict{Base.UUID, Vector{Float32}}}}"><code>gen_fulldict</code></a>. <code>colors</code> specifies the palette for trajectory colors, defaulting to <code>palette(:tab10)</code>. For <code>scaling</code> and <code>shift</code>, refer to <a href="#ParticleHolography.particleplot-Tuple"><code>particleplot</code></a>. <code>framerange</code> specifies the range of frames to plot. For example, when generating <code>fulldict</code> for N consecutive frames, setting <code>framerange=(N-10+1, N)</code> will plot only the trajectories of the last 10 frames. When creating animations with the <code>@anim</code> macro, setting <code>framerange</code> from <code>(1,1)</code> to <code>(1,N)</code> will create an N-frame animation.</p><p><strong>Arguments</strong></p><ul><li><code>paths::Vector{Vector{UUID}}</code>: The trajectories of the particles.</li><li><code>fulldict::Dict{UUID, Vector{Float32}}</code>: The dictionary of all particles.</li></ul><p><strong>Optional keyword arguments</strong></p><ul><li><code>colors::Vector{Colorant} = palette(:tab10)</code>: The colors of the trajectories.</li><li><code>framerange::Tuple{Int, Int} = (0, 1024)</code>: The range of frames to plot.</li><li><code>scaling::Tuple{Float32, Float32, Float32} = (1.0, 1.0, -1.0)</code>: The scaling of the coordinates.</li><li><code>shift::Tuple{Float32, Float32, Float32} = (0.0, 0.0, 0.0)</code>: The shift of the coordinates.</li><li><code>kwargs...</code>: Additional keyword arguments passed to Plots.@series.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dainakai/ParticleHolography.jl/blob/daf5c5b0b2f5ab0da18923971d43f8be504941eb/src/plot_recipes.jl#L51-L67">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../usage/animplot/">« Animated plots</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Tuesday 21 January 2025 06:20">Tuesday 21 January 2025</span>. Using Julia version 1.11.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
